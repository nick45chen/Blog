{"pages":[],"posts":[{"title":"[Android] Job scheduler","text":"IntroductionJob Sceduler 是一種高效的背景作業，能在一定程度上提高電池的使用壽命，同時也能給開發者節省開發的時間。 在Android 開發中，你可能會遇到，需要在某個時間點或滿足某個條件時，才執行特定的任務。例如：當設備連上Wi-Fi或接上電源的時候，或是每過15分鐘，定期上傳數據資料，在以前我們可能考慮過使用 Handlers 延遲上傳，但萬一用戶或系統關閉他們的應用程式呢？這時你可能會考慮使用AlarmManager ，前提是在用戶沒有關機過的狀態下，才能正常運行。另外，我們還沒把網路狀態改變的情況(斷線)考慮進去，這時你可能需要註冊一個廣播，在網路恢復時進行額外的邏輯處理，以確保你的程序正常的執行。 以上種種情形，真的是會讓開發者苦惱許久，幸運的是現在Google都幫你準備好了，Job Sceduler已經與新的系統緊密的結合，你只需要事先設定好執行的條件，條件的判斷就交給系統去處理，這你支新的API只會在你滿足條件時執行。 看看我們實際上如何做到這一點 1.創建Job Service123456789101112131415public class JobSchedulerService extends JobService { @Override public boolean onStartJob(JobParameters params) { //返回true，表示該工作耗時，需要執行結束時手動調用jobFinished()，來銷毀任務 //返回false，代表任務處理不需要很長的時間，在resurn時已經處理結束 return false; } @Override public boolean onStopJob(JobParameters params) { //只有在 onStartJob() 返回ture時，手動調用 jobFinished() 後才會執行此方法 //返回false來銷毀此工作 return false; }} 2.創建一個JobScheduler對象123//job id 用以區別任務int JOB_ID = 0JobInfo.Builder jobBuilder = JobInfo.Builder(JOB_ID, new ComponentName(getPackageName(), JobSchedulerService.class.getName())); JobInfo.Builder 還允許你設定不同的條件，任務只會在符合設置條件時執行1234567891011121314151617181920//設置任務延遲執行的時間，單位毫秒jobBuilder.setMinimumLatency(long minLatencyMillis)//設置任務最後延遲時間，如果時間到了其他條件還未滿足，任務也會啟動 jobBuilder.setOverrideDeadline(long maxExecutionDelayMillis)//設置在有網路連線的狀態下執行，預設是NETWORK_TYPE_NONE，意即不需要網路jobBuilder.setRequiredNetworkType(int networkType);//是否在充電時執行，並非充電馬上觸發，只有在電量健康的時候(&gt;15%)，才會觸發//jobBuilder.setRequiresCharging(boolean requiresCharging)//設置是否在設備重啟後，要繼續執行jobBuilder.setPersisted(boolean isPersisted)//設置任務運行的週期，與setMinimumLatency()和setOverrideDeadline()不兼容，同時設置會引發異常jobBuilder.setPeriodic(long time)//是否在空閒的時候執行，只有當用戶一段時間沒有使用設備時，才會觸發jobBuilder.setRequiresDeviceIdle(boolean requiresDeviceIdle) 3.構建一個JobIndo對象，並將它發送到JobScheduler中12JobScheduler mJobScheduler = (JobScheduler)getSystemService(Context.JOB_SCHEDULER_SERVICE);mJobScheduler.schedule(jobBuilder.build()) 在JobScheduler.schedule(JobInfo jobInfo)中，會返回一個int值，代表此任務是否安排成功，如果返回值小於0，代表任務失敗，反之則會返回該任務的id123if ((mJobScheduler.schedule(jobBuilder.build())) &lt;= 0) { Log.i(TAG, \" something goes wrong\")} 參考網站：Android JobSchedulerAndroid Intelligent Job-SchedulingYoutube Android Developer","link":"/Blog/2017/10/21/Android-Job%20scheduler/"},{"title":"[Material Design] Android Toolbar(一)","text":"IntroductionToolbar 是 Google 在Android 5.0 推出的一個 Material Design 的控件，Toolbar 的靈活性在於並不只限於只能放在上方導航欄的位置上，同時也能嵌套在任意的 View 結構中，當然你可以在 Activity 中，呼叫 setActionBar() 方法，把 Toolbar 指定為上方導航欄使用。 Toolbar 還開放讓開發者，自訂： 1.支持自訂按鈕2.支持設置品牌Logo3.支持設置標題和子標題4.支持添加一個或多個自定義的控件5.支持設置 Action Menu Create Toolbar1.進入 res -&gt; values -&gt; style ，修改App的樣式為 NoActionBar 12345678&lt;resources&gt; ... &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 2.在 Activity 的 Layout XML 引用 support.v7 包下的 Toolbar 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;RelativeLayout ... &gt; ... &lt;android.support.v7.widget.Toolbar .. /&gt;&lt;/RelativeLayout&gt; 3.如果我們讓 Toolbar 同系統預設的 Action bar 高，寬就使用 match_parent 符合螢幕就好，顏色也是同系統預設 ActionBar 的顏色 12345&lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\"/&gt; 4.XML 完成後，我們回到 Activity ，呼叫 Activity 中的 setActionBar() 方法，把 Action bar 換成自己的 Toolbar 123456789101112public class MainActivity extends AppCompatActivity { ... @Override protected void onCreate(Bundle saveInstanceState) { super.onCreate(saveInstanceState) setContentView(R.layout.activity_main); ... setSupportActionBar(toolbar); }} Customize the Toolbar接下來我們來客製化自己的 ToolBar 顏色，顏色的來源就從 Google Material 官網選擇Material Design Color或是參考熱心網友整理成的XMLAndroid Material Design Colours 1.進入res -&gt; values -&gt; colors ，改變 color primary 的顏色，就可以換掉我們的 Toolbar 顏色了，通常我們會連 color promary dark 一起換掉。(1) color primary 代表 Toolbar 顏色，通常我們會選擇數值 400 ~ 600間(2) color primary 代表 Status Bar (Action Bar 上面顯示電池電量那一欄) 顏色，通常我們會選擇顏色深一點 數值約 700 ~ 900間我們是選擇 Red-500/700 123456&lt;resources&gt; ... &lt;item name=\"colorPrimary\"&gt;#F44336&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;#D32F2F&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;#D32F2F&lt;/item&gt;&lt;/resources&gt; 完成到了這邊可以看到預覽效果 這邊你會想說，ToolBar Label 怎麼是黑色的，我想要換成白色該怎麼辦?!別擔心，只要把 ToolBar Theme 換成 Dark ActionBar就好，此 Theme 的文字顏色是白色 123456&lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"/&gt; 顯示出來的效果如下： 或許眼尖的你會發現，有些手機在螢幕下方有一排 Navigation Bar，如果我們有需求要改變顏色怎麼辦!?只要在 res -&gt; values -&gt; style 找到 AppTheme 中更改顏色就好，我們也把它設定成跟 Status Bar 顏色相同 123456789&lt;resources&gt; ... &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;item name=\"android:navigationBarColor\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 顯示出來的效果如下： 參考網站：Android ToolBarMaterial Design","link":"/Blog/2017/11/19/MaterialDesign-Android-Toolbar(%E4%B8%80)-Create-Toolbar/"},{"title":"[Material Design] Android Toolbar(二) - Pop-up Menu","text":"Introduction接下來我們來介紹 Pop-up Menu ， Pop-up Menu 使用在很多應用中，對開發者跟使用者都非常方便，而且我們可以自定義功能項，加到我們的 Toolbar 中。 Create Pop-up Menu1.在res目錄下，創建 menu file 2.進入剛剛創建的 menu file 新增 item tag，然後再 tag 中定義屬性 id 與 title，title 為顯示在 UI 畫面上的名稱 3.回到 Activity 中，Override 兩個 Methods 1234567891011121314public class MainActivity extends AppCompatActivity { ... @Override protected void onCreateOptionsMenu(Menu menu) { return super.onCreateOptionsMenu(menu); } @Override protected void onOptionsItemSelected(Menu menu) { return super.onOptionsItemSelected(item); }} 4.使用 onCreateOptionsMenu() 創建 Pop-up Menu ，並使用 onOptionsItemSelected() 監聽點擊事件，點擊事件我們用 id 判別不同的 item 項 12345678910111213141516171819202122@Overridepublic boolean onCreateOptionsMenu(Menu menu) { getMenuInflater().inflate(R.menu.menu_main, menu); return true; }@Overridepublic boolean onOptionsItemSelected(MenuItem item) { //取得 menu id 來判斷是哪一個 item 被選中，並用 Toast 回饋給使用者 switch (item.getItemId()) { case R.id.item1_id: Toast.makeText(this, \"item 1\", Toast.LENGTH_SHORT).show(); break; case R.id.item2_id: Toast.makeText(this, \"item 2\", Toast.LENGTH_SHORT).show(); break; case R.id.item3_id: Toast.makeText(this, \"item 3\", Toast.LENGTH_SHORT).show(); break; } return super.onOptionsItemSelected(item); } 5.之後就可以在畫面上我們創建的 Menu，點擊 item 1 會觸發點擊事件 Customize Pop-up Menu在預設的 Pop-up Menu 中，背景顏色是黑色，對於我們的 App theme 看來非常不美觀，所以我們要做的第一件事是把 Pop-up Menu 的背景顏色換掉 Change Background Color1.首先進入 res -&gt; values -&gt; style 目錄下，新增一個 style tag ，名稱我們叫做 PopupTheme 並新增一個屬性 android:background ，這邊你可以自定義 Pop-up Menu 的背景顏色，我們使用白色 123456&lt;resources&gt; ... &lt;style name=\"PopupTheme\" parent=\"Theme.AppCompat.Light\"&gt; &lt;item name=\"android:background\"&gt;@android:color/white&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 2.接著把自定義的 PopupTheme 替換掉在 AppTheme 裡 popupTheme 的屬性 12345678910111213&lt;resources&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;item name=\"popupTheme\"&gt;@style/PopupTheme&lt;/item&gt; &lt;/style&gt; &lt;style name=\"PopupTheme\" parent=\"Theme.AppCompat.Light\"&gt; &lt;item name=\"android:background\"&gt;@android:color/white&lt;/item&gt; &lt;/style&gt; ...&lt;/resources&gt; 接著就可以看到效果 Change Text Color如果你還有改變文字顏色的需求，你可以在剛剛自定義的 PopupTheme 中，添加屬性 android:textColor 自定義文字顏色 1234567891011121314&lt;resources&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;item name=\"popupTheme\"&gt;@style/PopupTheme&lt;/item&gt; &lt;/style&gt; &lt;style name=\"PopupTheme\" parent=\"Theme.AppCompat.Light\"&gt; &lt;item name=\"android:background\"&gt;@android:color/white&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;@color/colorPrimary&lt;/item&gt; &lt;/style&gt; ...&lt;/resources&gt; 效果如下 參考網站：Android ToolBarMaterial Design","link":"/Blog/2017/11/24/MaterialDesign-Android-Toolbar(%E4%BA%8C)-Pop-up-Menu/"},{"title":"[Material Design] Android Toolbar(三) - Add-Action","text":"Introduction除了 Pop-up Menu 外，我們還可以在 Toolbar 上自定義 action 例如： Add Action to Toolbar1.首先我們需要取得我們要顯示的 icon ，你可以在 Material Design 官網上尋找，或是在 Material Design icon 上，尋找符合你需求且具有 Materical style 的 icon 2.接下來把下載下來的 icon 放在根目錄下 res -&gt; drawable 目錄下，這邊比較需要注意的地方，要放在 Toolbar 的 action icon 尺寸最好為 48 或是 24，更詳細資訊請參考 Material icons 3.接下來進到 res -&gt; menu 目錄下，打開我們新增 Pop-up Menu 的 XML 檔，在下面新增一個 item tag 1234567891011121314151617181920212223&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; ... &lt;item android:id=\"@+id/item1_id\" android:title=\"@string/main_item1\" /&gt; &lt;item android:id=\"@+id/item2_id\" android:title=\"@string/main_item2\" /&gt; &lt;item android:id=\"@+id/item3_id\" android:title=\"@string/main_item3\" /&gt; &lt;item android:id=\"@+id/search_id\" android:title=\"\" android:icon=\"@drawable/ic_search_white_24dp\" app:showAsAction=\"always\"/&gt; ...&lt;/menu&gt; 因為我們要顯示的是 icon 所以 title 不需要，留空，icon 使用我們剛剛下載放在 drawable 資料夾下的 icon ，showAsAction 屬性設定，有分為三種 1.always 是強制顯示 icon 2.ifRoom 是如果還有空間的話就顯示，沒有就隱藏在 pop-up menu 裡 3.never 是隱藏，只顯示在 Pop-up Menu 中 比較值得注意的是，如果你的 action 有超過一個以上，系統會建議你使用 ifRoom 在空間不夠的時候，會改顯示在 Pop-up Menu(ifRoom/never) 中，那你最好也把 title 加上去。 效果如下 如果你設定 ifRoom 在空間不足或是 設定 never 時，效果如下 4.如果仔細觀察市面上的 App 通常在 Toolbar 的左側，只會有一個按鈕，其中一種是用來返回上一頁，或結束此頁，接下來我們來新增左邊的 Action。回到Activity中，在onCreate()的方法中，呼叫supporActionBar的setDisplayHomeAsUpEnabled()方法，將其設定為 true 12345678910111213public class MainActivity extends AppCompatActivity { ... @Override protected void onCreate(Bundle saveInstanceState) { super.onCreate(saveInstanceState) setContentView(R.layout.activity_main); ... setSupportActionBar(toolbar); getSupportActionBar().setDisplayHomeAsUpEnabled(true); }} 左側的返回鍵按鈕就跑出來了 Add On-Click Listener to the Action在監聽點擊事件方面，原則上與 Pop-up Menu 相同，可以參考上一篇 [Material Design] Android Toolbar(二) - Pop-up Menu。特別的一點是，如果我們想新增左側返回鍵按鈕的 function，我們同樣也是回到 Activity 的 onOptionsItemSelected() 中做判斷 1234567891011@Overridepublic boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()) { ... // 左側返回鍵的 id case android.R.id.home: finish(); break; } return super.onOptionsItemSelected(item);} 參考網站：Material iconsAndroid Adding and Handling ActionsMaterial Design","link":"/Blog/2017/11/26/MaterialDesign-Android-Toolbar(%E4%B8%89)-Add-Action/"},{"title":"[Material Design] Android Navigation Drawer(二) - Add OnClickListener","text":"Introduction接下來我們在點擊 Navigation Drawer item 時，加入點擊事件 Implement the method首先我們先在代碼裡，呼叫 setNavigationItemSelectedListener 方法，去添加 Listener，接下來在 activity class 下實現 NavigationView.OnNavigationItemSelectedListener 接口，並覆寫 onNavigationItemSelected 方法 12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity implements NavigationView.OnNavigationItemSelectedListener { Toolbar toolbar; DrawerLayout drawerLayout; NavigationView navigationView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.navigation_drawer); toolbar = findViewById(R.id.toolbar); setSupportActionBar(toolbar); drawerLayout = findViewById(R.id.drawer_layout); navigationView = findViewById(R.id.navigation_view); //這邊添加 NavigationItemSelectedListener navigationView.setNavigationItemSelectedListener(this); ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this, drawerLayout, toolbar, R.string.open_drawer, R.string.close_drawer); drawerLayout.addDrawerListener(toggle); toggle.syncState(); } @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) { // 實現此方法 return false; }} Add function接下來在 onNavigationItemSelected 方法中，把return 改為 true，並在方法裡取出 MenuItem 的 id 以 switch 判別哪個 item 被點擊。在 switch 部份結束後，我們呼叫 drawerLayout closeDrawer() 方法，表示在點擊事件結束後，會關閉 drawer。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MainActivity extends AppCompatActivity implements NavigationView.OnNavigationItemSelectedListener { ... @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) { int id = item.getItemId(); switch (id) { case R.id.inbox_id: // 這邊新增要呼叫的方法 Toast.makeText(getApplicationContext(), \"inbox\", Toast.LENGTH_LONG).show(); break; case R.id.starred_id: Toast.makeText(getApplicationContext(), \"starred\", Toast.LENGTH_LONG).show(); break; case R.id.sent_id: Toast.makeText(getApplicationContext(), \"sent mail\", Toast.LENGTH_LONG).show(); break; case R.id.drafts_id: Toast.makeText(getApplicationContext(), \"drafts\", Toast.LENGTH_LONG).show(); break; case R.id.allmail_id: Toast.makeText(getApplicationContext(), \"all mail\", Toast.LENGTH_LONG).show(); break; case R.id.trash_id: Toast.makeText(getApplicationContext(), \"trash\", Toast.LENGTH_LONG).show(); break; case R.id.spam_id: Toast.makeText(getApplicationContext(), \"spam\", Toast.LENGTH_LONG).show(); break; } // 關閉 drawer，GravityCompat.START 表示 drawer 關閉會回到螢幕的左方 drawerLayout.closeDrawer(GravityCompat.START); return true; }} 運行效果如下: 參考網站:Android DeveloperMaterial Design","link":"/Blog/2017/12/30/MaterialDesign-Android-Navigation-Drawer(%E4%BA%8C)-Add-OnClickListener/"},{"title":"[Material Design] Android Navigation Drawer(三) - Customize the Navigation Drawer","text":"Introduction在本篇文章中，我們要客製化實現數種 Navigation Drawer 展開時的顯示方式 Placing the Navigation Drawer inside status bar接下來我們要設定 Navigation Drawer 展開時會符合整個螢幕，不會受到 status bar 限制 首先我們打開 values 目錄下的 styles.xml 文件，創建一個新 style name = “AppTheme.NoActionBar” 接下來我們打開 manifests 目錄下 AndroidManifest.xml 文件，修改我們顯示 Navigation drawer 的 Activity Theme 為剛剛創建的 style 接著回到剛剛創建的 style tag 下，增加幾條屬性 123456789101112131415&lt;resources&gt; ... &lt;style name=\"AppTheme.NoActionBar\"&gt; &lt;!--此屬性表示 Activity 不會有預設的 Toolbar--&gt; &lt;item name=\"windowActionBar\"&gt;false&lt;/item&gt; &lt;!--此屬性表示 Activity 預設的 Toolbar 將不會有 label--&gt; &lt;item name=\"windowNoTitle\"&gt;true&lt;/item&gt; &lt;item name=\"android:windowDrawsSystemBarBackgrounds\"&gt;true&lt;/item&gt; &lt;!--此屬性表示 status bar 背景為透明--&gt; &lt;item name=\"android:statusBarColor\"&gt;@android:color/transparent&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 運行效果如下: Placing the Navigation Drawer under the Toolbar接下來我們要設定 Navigation Drawer 展開時，不會覆蓋到 Toolbar，會在其下方 首先，我們要先把上一部分新增的 style 移除，並將 manifests 的 Activity theme屬性移除 緊接著我們打開 layout目錄下 navigation_drawer.xml 文件，並在最外層新增一個 view group 佈局 接下來我們把 import activity 的 include tag 搬到最外層的 view group tag 下，並把 DrawerLayout tag 中修改屬性 android:fitsSystemWindows 為 false 與新增屬性 android:layout_marginTop=”?attr/actionBarSize” 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout ... android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;include layout=\"@layout/activity_main\"/&gt; &lt;android.support.v4.widget.DrawerLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/drawer_layout\" android:layout_marginTop=\"?attr/actionBarSize\" android:fitsSystemWindows=\"false\" tools:openDrawer=\"start\"&gt; &lt;android.support.design.widget.NavigationView android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:id=\"@+id/navigation_view\" android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\" app:headerLayout=\"@layout/navigation_header\" app:menu=\"@menu/navigation_menu\"/&gt; &lt;/android.support.v4.widget.DrawerLayout&gt;&lt;/RelativeLayout&gt; 運行效果如下: 這時候我們想要在 Navigation Drawer 打開時，讓背景 activity 顯示為灰色，首先需要把 include activity tag 重新放回 DrawerLayout tag 中，並移除屬性 android:layout_marginTop=”?attr/actionBarSize”，最後一步在 NavigationView tag 下新增屬性 android:layout_marginTop=”?attr/actionBarSize” 與修改屬性 android:fitsSystemWindows 為 false 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout ... android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v4.widget.DrawerLayout android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"false\" android:orientation=\"vertical\" tools:openDrawer=\"start\"&gt; &lt;include layout=\"@layout/activity_main\" /&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/navigation_view\" android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:layout_marginTop=\"?attr/actionBarSize\" android:fitsSystemWindows=\"false\" app:headerLayout=\"@layout/navigation_header\" app:menu=\"@menu/navigation_menu\" /&gt; &lt;/android.support.v4.widget.DrawerLayout&gt;&lt;/RelativeLayout&gt; 運行效果如下: 可能你又有以下需求，我只要 activity 背景變暗就好，Toolbar 不用 首先在 res -&gt; layout 目錄下新增一個 toolbar_layout.xml 接著把 activity 中的 toolbar tag 移除 再回到 navigation_drawer.xml 文件下，將剛剛新增的 toolbar_layout.xml 利用 include tag import 進來，並將 NavigationView tag 的屬性 android:layout_marginTop=”?attr/actionBarSize” 移動到 DrawerLayout tag 中 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout ... android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;include layout=\"@layout/toolbar_layout\"/&gt; &lt;android.support.v4.widget.DrawerLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/drawer_layout\" android:layout_marginTop=\"?attr/actionBarSize\" android:fitsSystemWindows=\"false\" tools:openDrawer=\"start\"&gt; &lt;include layout=\"@layout/activity_main\"/&gt; &lt;android.support.design.widget.NavigationView android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:id=\"@+id/navigation_view\" android:layout_gravity=\"start\" android:fitsSystemWindows=\"false\" app:headerLayout=\"@layout/navigation_header\" app:menu=\"@menu/navigation_menu\"/&gt; &lt;/android.support.v4.widget.DrawerLayout&gt;&lt;/RelativeLayout&gt; 運行效果如下: 參考網站:Android DeveloperMaterial Design","link":"/Blog/2018/01/01/MaterialDesign-Android-Navigation-Drawer(%E4%B8%89)-Customize-the-Navigation-Drawer/"},{"title":"[MaterialDesign] Android Buttons","text":"Introduction在Material Design中，Button 共分為三類 Raised button凸起式按鈕，按下去會有一個下壓的效果 Flat button平面按鈕，也稱作純文本按鈕，並沒有像Raised buttons一樣，有下壓效果，常用於 dialog、toolbar中 Floating button顧名思義就是浮著的Button，在設計上通常一個介面只會存在一個，代表此頁最常見的功能鈕 接下來我們來看看在Android裡如何實現。 Create a Raised button使用Raised buttons很容易，只要在 layout 裡直接引用AppConpact Library裡的，具有Material features 的 AppCompatButton 就可以了 layout: 1234&lt;android.support.v7.widget.AppCompatButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/raised_button\"/&gt; 運行效果如下： 如何更換AppCompatButton的按鈕顏色呢？首先打開sytles.xml文件，在裡面創建一個 new style 定義背景及文字顏色 styles.xml: 1234567&lt;resources&gt; ... &lt;style name=\"RaiseButton\" parent=\"Widget.AppCompat.Button.Colored\"&gt; &lt;item name=\"android:backgroundTint\"&gt;@color/colorRaisedButton&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;@color/colorRaisedButtonText&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 接著再回到 layout 文件的AppCompatButton中，設定剛剛新增的 style layout: 12345&lt;android.support.v7.widget.AppCompatButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/raised_button\" style=\"@style/RaiseButton\"/&gt; 運行效果如下： Create a Flat button創建Flat button也很容易，打開sytles.xml文件，在裡面創建一個 new style，Widget.AppCompat.Button.Borderless 表示你的按鈕背景為透明，當然你也可以在style裡，定義文字的顏色 styles.xml: 123456&lt;resources&gt; ... &lt;style name=\"FlatButton\" parent=\"Widget.AppCompat.Button.Borderless\"&gt; &lt;/style&gt;&lt;/resources&gt; 接著創建一個AppCompatButton，把sytle設定進去就好 layout: 12345&lt;android.support.v7.widget.AppCompatButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/flat_button\" style=\"@style/FlatButton\"/&gt; 運行效果如下： Create a Floating Action Button接下來我們來創建Floating Action Buttonn，首先要先確認Design Library有加進我們的Project 之後就可以在 layout 裡直接引用了 layout: 1234&lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab_btn\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; 運行效果如下： 你也可以在Floating Action Buttonn中，添加icon layout: 12345&lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab_btn\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/ic_dialog_email\" /&gt; 運行效果如下： 設定Floating Action Buttonn的size以 size 可分為:1.noraml circle = 56x56dp2.Mini circle = 40x40dp layout: 123456&lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab_btn\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/ic_dialog_email\" app:fabSize=\"normal\" /&gt; 運行效果如下： Floating Action Buttonn還有一個很符合此命名的屬性 elevation其中 elevation 設定的 DP 越大，則按鈕背後的陰影也會越大 layout: 1234567&lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab_btn\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/ic_dialog_email\" app:fabSize=\"normal\" app:elevation=\"8dp\" /&gt; 運行效果如下： Floating Action Buttonn的背景顏色預設是@color/colorAccent，如果想要自訂背景顏色，只要改變屬性:backgroundTint就可以了layout: 1234567&lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab_btn\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/ic_dialog_email\" app:fabSize=\"normal\" app:backgroundTint=\"@color/holo_green_dark\" /&gt; 運行效果如下： 參考網站:Android DeveloperMaterial Design ButtonsMaterial Design Buttons: Floating Action Button","link":"/Blog/2018/01/12/MaterialDesign-Android-Buttons/"},{"title":"[MaterialDesign] Android Selection Controls","text":"IntroductionSelection Controls是在Android上很常見的元件，這些控制元件包括 Switches、CheckBoxes、Radio buttons接下來我們使用support.v7.widget包下的元件，來看看這些具有Material Features的元件怎麼使用，這邊值得注意的一點是，support.v7.widget包下的元件，要顯示Material Features需在Android版本Lollipop(5.0)之後的版本。 Create a SwitchCompat首先在layout文件下，引用support.v7.widget包下的SwitchCompat layout: 12345&lt;android.support.v7.widget.SwitchCompat android:id=\"@+id/switch_id\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/switch_off_on\"/&gt; 運行效果如下： SwitchCompat預設的狀態都是false，想要改變預設狀態，只要在SwitchCompat添加屬性android:checked就行了 1android:checked=\"true\" SwitchCompat的顏色預設是使用@color/colorAccent，想要改變顏色，需先創建一個新style，並自訂colorAccent的顏色 styles.xml: 123456&lt;resources&gt; ... &lt;style name=\"SwitchTheme\"&gt; &lt;item name=\"colorAccent\"&gt;@color/colorTealA200&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 接著在SwitchCompat添加屬性app:theme為我們自定義的新style 1app:theme=\"@style/SwitchTheme\" 運行效果如下： 在程式碼裡監聽點擊事件 123456switchCompat.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() { @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { // 這邊監聽點擊事件 } }); Create an AppcompatCheckBox在layout文件下，引用support.v7.widget包下的AppcompatCheckBox layout: 12345&lt;android.support.v7.widget.AppCompatCheckBox android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:id=\"@+id/checkbox_id\" android:text=\"@string/checkbox\"/&gt; 運行效果如下： 改變預設狀態，只要在AppcompatCheckBox添加屬性android:checked就行了 1android:checked=\"true\" AppcompatCheckBox的顏色1.狀態true時，使用colorAccent2.狀態false時，使用colorControlNormal改變顏色，需要創建一個新style，並在裡面定義兩個item的顏色 styles.xml: 1234567&lt;resources&gt; ... &lt;style name=\"CheckBoxTheme\"&gt; &lt;item name=\"colorAccent\"&gt;@color/colorTealA200&lt;/item&gt; &lt;item name=\"colorControlNormal\"&gt;@color/colorDeepOrangeA200&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 接著在AppcompatCheckBox添加屬性app:theme為我們自定義的新style 1app:theme=\"@style/CheckBoxTheme\" 運行效果如下： 在程式碼裡監聽點擊事件 123456checkBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() { @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { // 這邊監聽點擊事件 } }); Create an AppCompatRadioButtonAppCompatRadioButton 比較值得注意一點是，它只要state = true後，就無法透過點擊設為false在layout文件下，引用support.v7.widget包下的AppCompatRadioButton layout: 12345&lt;android.support.v7.widget.AppCompatRadioButton android:id=\"@+id/radioButton1_id\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/radiobutton_1\"/&gt; 運行效果如下： 改變預設狀態，只要在AppCompatRadioButton添加屬性android:checked就行了 1android:checked=\"true\" AppCompatRadioButton的顏色預設是使用@color/colorAccent，想要改變顏色，首先需要創建一個新style，自訂colorAccent的顏色 styles.xml: 123456&lt;resources&gt; ... &lt;style name=\"RadioButtonTheme\"&gt; &lt;item name=\"colorAccent\"&gt;@color/colorTealA200&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 接著在SwitchCompat添加屬性app:theme為我們自定義的新style 1app:theme=\"@style/RadioButtonTheme\" 運行效果如下： 在程式碼裡監聽點擊事件 123456radioButton.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() { @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { // 這邊監聽點擊事件 } }); Add a RadioGroup to the AppcompatRadioButton如果我們想要創建一排AppcompatRadioButton列表，並保持列表中，只有一個state = true(被選中)，其他為false，那麼就需要使用RadioGroupRadioGroup使用起來很簡單，只要引用在AppcompatRadioButton外層就行了 layout: 123456789101112131415161718192021222324&lt;RadioGroup android:id=\"@+id/radioGroup_id\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt; &lt;android.support.v7.widget.AppCompatRadioButton android:id=\"@+id/radioButton1_id\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/radiobutton_1\" /&gt; &lt;android.support.v7.widget.AppCompatRadioButton android:id=\"@+id/radioButton2_id\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/radiobutton_2\" /&gt; &lt;android.support.v7.widget.AppCompatRadioButton android:id=\"@+id/radioButton3_id\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/radiobutton_3\" /&gt; &lt;/RadioGroup&gt; 運行效果如下： 在程式碼裡監聽點擊事件 123456radioGroup.setOnCheckedChangeListener(new RadioGroup.OnCheckedChangeListener() { @Override public void onCheckedChanged(RadioGroup group, int checkedId) { // 這邊監聽點擊事件 } }); 參考網站:Android SwitchCompatAndroid AppCompatCheckBoxAndroid AppCompatRadioButtonAndroid RadioGroupMaterial Design Selection controls","link":"/Blog/2018/01/15/MaterialDesign-Android-Selection-Controls/"},{"title":"[MaterialDesign] Android Progress Bar","text":"IntroductionProgressBar是在Android常見的元件，尤其是在materials design上，依照 UI 上顯示的方式，可以初步分類成兩種：1.Linear長條形2.Circular圓型接下來我們來看看如何使用。 Create a Circular Progress Bar在layout文件下，直接引用ProgressBar layout: 1234&lt;ProgressBar android:id=\"@+id/progress_id\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; 運行效果如下： ProgressBar顏色預設是使用@color/colorAccent，想要改變顏色，需先創建一個新style，並自訂colorAccent的顏色 styles.xml: 123456&lt;resources&gt; ... &lt;style name=\"ProgressTheme\" parent=\"Widget.AppCompat.ProgressBar\"&gt; &lt;item name=\"colorAccent\"&gt;@color/colorDeepOrangeA200&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 接著在ProgressBar添加屬性android:theme為我們自定義的新style 1android:theme=\"@style/ProgressTheme\" 運行效果如下： Create a Linear Progress BarLinear Progress Bar 依照顯示的型態，又可細分成4項1.Determinate(定值) -有定值，顯示在進度條上，需要定義當前值與最大值2.Indeterminate(不定值) -無定值，UI顯示上會從進度條開始，快速到結束，重複循環3.Buffer(緩衝) -影片或加載圖片很常用到的緩衝進度條，通常是顯示在確定值的後方4.Query Indeterminate and Determinate (混合) -結合 Determinate 和 Indeterminate 的進度條 創建一個Linear Progress Bar，方法很簡單，在剛剛創建的ProgressBar添加上一條style屬性，此時就會發現ProgressBar已經顯示為長條形 1style=\"@style/Widget.AppCompat.ProgressBar.Horizontal\" 接著再加上一條屬性android:indeterminate，表示ProgressBar為不定值，會像** Circular Progress Bar ** 一樣，有循環的效果 1android:indeterminate=\"true\" 運行效果如下： 接下來我們來創建 Determinate(定值) ProgressBar 先把屬性android:indeterminate，設為false 1android:indeterminate=\"false\" 接著設定屬性進度值與最大值，Android會自動換算成百分比 12android:progress=\"20\"android:max=\"100\" 當然也可以在代碼裡設定 12progressBar.setProgress(20);progressBar.setMax(100); 運行效果如下： 使用Buffer(緩衝) ProgressBar，需在ProgressBar裡添加屬性 android:secondaryProgress，就可以在畫面上，看見一條緩衝進度條效果 1android:secondaryProgress=\"40\" 當然也可以在代碼裡設定 1progressBar.setSecondaryProgress(40); 運行效果如下： 參考網站:Android ProgressBarMaterial Design Progress &amp; activity","link":"/Blog/2018/01/17/MaterialDesign-Android-Progress-Bar/"},{"title":"[MaterialDesign] Android Dialogs","text":"Introduction在開發App的過程中，有一些情況下，你必須請使用者做一些決定，或是向使用者提醒一些錯誤，這時候就需要用到Dialog，在Material Design出現之前，Dialog的樣式的確不太美觀，接下來我們實際演示，如何使用具Material Design Features的Dialog 如果你使用新版的Android Studio 3.0，專案預設會幫你載入support:appcompat-v7包，創建AlertDialog時，記得引用此包，不要用app內建的 使用系統內的android.app.AlertDialog在4.x版本，顯示效果如下：5.0以上系統已經預設使用Material Design的風格 如果使用android.support.v7.app.AlertDialog，在4.x版本下，也能有與5.0以上樣式相似的效果 Alert Dialog常用於錯誤通知、或提示使用者接下來行為/動作 Create an Alert Dialog接下來我們用代碼來創建一個AlertDialog 1234new AlertDialog.Builder(this) .setMessage(\"Discard draft?\") .create() .show(); 運行效果如下： 使用AlertDialog通常會搭配使用兩個按鈕(flat button)，右邊按鈕通常放置確定/同意…等動作，左邊按鈕通常放置取消/不同意…等動作 123456new AlertDialog.Builder(this) .setMessage(\"Discard draft?\") .setPositiveButton(\"DISCARD\", null) //創建右邊按鈕，第二個參數 listener 可以監聽點擊事件 .setNegativeButton(\"CANCEL\", null) //創建左邊按鈕，第二個參數 listener 可以監聽點擊事件 .create() .show(); 運行效果如下： Customize the Alert Dialog改變按鈕的顏色，有兩種方法，第一種是直接在代碼裡定義兩個按鈕的顏色 12345678910alertDialog = new AlertDialog.Builder(this) .setMessage(\"Discard draft?\") .setPositiveButton(\"DISCARD\", null) //創建右邊按鈕，第二個參數 listener 可以監聽點擊事件 .setNegativeButton(\"CANCEL\", null) //創建左邊按鈕，第二個參數 listener 可以監聽點擊事件 .create();alertDialog.show();// 取得右邊按鈕，改變文字顏色alertDialog.getButton(AlertDialog.BUTTON_POSITIVE).setTextColor(ContextCompat.getColor(this, R.color.colorLightBlue)); 運行效果如下： 可以看到右邊的文字顏色已經改變，如果還需要改變左邊按鈕文字顏色可以加入下方代碼 1alertDialog.getButton(AlertDialog.BUTTON_NEGATIVE).setTextColor(ContextCompat.getColor(this, R.color.colorLightBlue)); 第二種方法是創建一個新style，在style裡改變colorAccent顏色，接著使用AlertDialog.Builder的constructor創建有自定義style的Dialog點進AlertDialog.Builder的代碼，可以發現多態constructor 1234567package android.support.v7.app;...public class AlertDialog extends AppCompatDialog implements DialogInterface { ... public Builder(@NonNull Context context){...} public Builder(@NonNull Context context, @StyleRes int themeResId){...}} 在styles.xml裡，是創建一個新style，並在style裡自訂colorAccent顏色 123&lt;style name=\"AlertDialogTheme\" parent=\"Theme.AppCompat.Light.Dialog.Alert\"&gt; &lt;item name=\"colorAccent\"&gt;@color/colorLightBlue&lt;/item&gt;&lt;/style&gt; 接著回到代碼裡，在創建AlertDialog同時，把剛剛自訂的style添加進去 123456new AlertDialog.Builder(this, R.style.AlertDialogTheme)// 添加style .setMessage(\"Discard draft?\") .setPositiveButton(\"DISCARD\", null) //創建右邊按鈕，第二個參數 listener 可以監聽點擊事件 .setNegativeButton(\"CANCEL\", null) //創建左邊按鈕，第二個參數 listener 可以監聽點擊事件 .create() .show(); 運行效果如下： Confirmation dialogs確認對話框，常用在尋求使用者做一個行為或是動作的選擇時使用，Confirmation dialogs通常包含標題、選擇內容、確認/取消按鈕 Create a Confirmation Dialog接下來在代碼裡創建一個Confirmation Dialog範例 12345678910111213141516// dialogs 裡面的選項String[] items = {\"None\", \"Callisto\", \"Ganymede\", \"Luna\"};// 創建一個 confirmation dialognew AlertDialog.Builder(this) .setTitle(\"Phone Ringtone\") // 設置單選選項，第二個參數可以設置默認選擇，-1表示默認無選擇 .setSingleChoiceItems(items, -1, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // 這邊監聽點擊事件 } }) .setPositiveButton(\"OK\", null) //創建右邊按鈕，第二個參數 listener 可以監聽點擊事件 .setNegativeButton(\"CANCEL\", null) //創建左邊按鈕，第二個參數 listener 可以監聽點擊事件 .create() .show(); 運行效果如下： Customize the Confirmation Dialog更換style樣式很簡單，與上面AlertDialog第二種方式相同，值得注意的是，套用style後，dialog裡面的內容，也會有改變 運行效果如下： ProgressDialog如果你還在用ProgressDialog，那你可要小心了，因為Android官網已經在API level 26時棄用它，官方的解釋是ProgressDialog是一個模態對話框(modal dialog)，它會禁止使用者與App的交互，作為替代方案，可以在App UI裡嵌入ProgressBar作為替代方案，如果想實現對話框的模式，亦可在AlertDialog裡嵌入ProgressBar來實現 在AlertDialog中嵌入含有ProgressBar的layout 這邊很簡單就不附上xml了layout: 在代碼裡創建AlertDialog，並把ProgressBar添加進去 new AlertDialog.Builder(this, R.style.AlertDialogTheme) .setTitle(\"Progress Dialog\") .setView(R.layout.layout_progress_bar) .create() .show(); 運行效果如下： 也可以使用Linear Progress Bar 關於ProgressBar更多細節，請參考[MaterialDesign] Android Progress Bar 參考網站:Android AlertDialogAndroid ProgressDialogAndroid Dialogs","link":"/Blog/2018/01/18/MaterialDesign-Android-Dialogs/"},{"title":"[MaterialDesign] Android Snackbar","text":"Introduction在Android開發中，每次當想要像用戶顯示一些訊息，我們可能會選擇Toast，但Toast使用起來卻有一些限制，不能在文本訊息顯示的同時，包含一些文本的操作，Google在support:design library下，推出了Snackbar可以讓使用者在文本訊息的使用上更美觀，同時擁有更多的彈性 Snackbar與Toast同時都為顯示在螢幕底部的文本訊息，Snackbar擁有以下特性：1.只能顯示文字，無法添加icon2.同時只能顯示單一個Snackbar，需連續顯示時，會等上一個dismiss後，才顯示3.只能定義一個action，且功能不是取消，如果需要兩個以上的action，請使用Dialogs 接下來我們就來實作Snackbar Create a Snackbar要使用Snackbar，首先需要把support:design library添加進我們的Project中，在 File -&gt; Project Structure -&gt; Dependencles 下新增。 接下來在代碼中使用Snackbar，第一個參數view必須傳入對應的根佈局，第二的參數是顯示文字，第三個參數是顯示的時間。 1Snackbar.make(@NonNull View view, @NonNull CharSequence text, @Duration int duration).show(); 12View rootView = findViewById(R.id.activity_main);Snackbar.make(rootView, \"Archived\", Snackbar.LENGTH_LONG).show(); 也可以透過代碼指定Snackbar持續的時間 123snackbar = Snackbar.make(root, \"Archived\", Snackbar.LENGTH_INDEFINITE);snackbar.setDuration(3000); // Snackbar.LENGTH_INDEFINITE 如果沒有指定時間，Snackbar將需不會取消snackbar.show(); 運行效果如下： Create a Snackbar Using CoordinatorLayout如果同時使用 FloatingActionButton 與 Snackbar，會發現 Snackbar 高度會覆蓋 FloatingActionButton，如果要解決這個問題，就要使用 CoordinatorLayout activity佈局如下，把FloatingActionButton放進CoordinatorLayouttag裡 layout: 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/activity_main\"&gt; &lt;android.support.design.widget.CoordinatorLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/fab_btn\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:layout_margin=\"16dp\" android:src=\"@drawable/ic_add_white_24dp\" app:fabSize=\"normal\" /&gt; &lt;/android.support.design.widget.CoordinatorLayout&gt;&lt;/android.support.constraint.ConstraintLayout&gt; java: 123456floatingActionButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Snackbar.make(view, \"Archived\", Snackbar.LENGTH_SHORT).show(); } }); 運行效果如下： 搭配CoordinatorLayout，可以使Snackbar出現在任何ViewGroup的底部，做出下方效果 Add an Action to the Snackbar如果要添加文字訊息對應的 action 操作的話，可以使用 setAction() 方法 1snackbar.setAction(CharSequence text, final View.OnClickListener listener); java: 123456789snackbar = Snackbar.make(rootView, \"Archived\", Snackbar.LENGTH_INDEFINITE);snackbar.setDuration(5000);snackbar.setAction(\"UNDO\", new View.OnClickListener() { @Override public void onClick(View v) { // 點擊事件 }});snackbar.show(); 運行效果如下： Customize the Snackbar如要改變Snackbar的含背景、訊息文字、按鈕文字顏色，則需要在呼叫show()方法前，增加以下代碼 1.背景顏色 java: 1234// 取出snackbar viewView view = snackbar.getView();// 更換view背景顏色view.setBackgroundColor(ContextCompat.getColor(MainActivity.this, R.color.colorSnackbarBackground)); 運行效果如下： 2.訊息文字顏色 java: 1234// 取出 message textviewTextView textView = snackbar.getView().findViewById(android.support.design.R.id.snackbar_text);// 改變文字顏色textView.setTextColor(ContextCompat.getColor(MainActivity.this, R.color.colorSnackbarText)); 運行效果如下： 3.Action文字顏色 java: 1234// 取出 action textviewTextView textView = snackbar.getView().findViewById(android.support.design.R.id.snackbar_action);// 改變文字顏色textView.setTextColor(ContextCompat.getColor(MainActivity.this, R.color.colorSnackbarAction)); 運行效果如下： 參考網站:Android SnackbarMaterial Design Snackbars &amp; toasts","link":"/Blog/2018/01/22/MaterialDesign-Android-Snackbar/"},{"title":"[MaterialDesign] Android Bottom Navigation","text":"IntroductionBottom Navigation在Material Design中算是相當重要的一個組件，通常會用在主頁底部的部分，在使用Bottom Design作為App設計上，有點要注意： 1.Bottom Navigation可以使用文字搭配圖示2.通常放置3個item，最多不超過5個，如果少於2個item，請使用Tabs，超過5個，可以使用Navigation drawers3.選中狀態下的顏色，建議使用App’s primary color或是同Toolbar的顏色，4.如果Bottom Navigation已經有背景顏色，那選中狀態的文字與圖示應使用白色或是黑色5.Bottom Navigation上的文字，盡量簡短明暸，以免發生文字斷行、縮小、未顯示的情形 接下來我們就來實作Bottom Navigation Create a Bottom Navigation在Android Studio中，也提中快速創建Bottom Navigation的模板，不過我們本篇會選用Empty Activity 1.要使用BottomNavigationView，首先需要把support:design library添加進我們的Project中，在 File -&gt; Project Structure -&gt; Dependencles 下新增。 2.接下來在layout裡，創建一個BottomNavigationView，背景顏色使用跟窗口背景顏色一樣 layout: 1234&lt;android.support.design.widget.BottomNavigationView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"?android:attr/windowBackground\"/&gt; 3.緊接著我們要創建BottomNavigationView 的 menu，在res -&gt; menu目錄下創建 menu: 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:title=\"@string/recents\" android:id=\"@+id/main_recents\" android:icon=\"@drawable/ic_recents_white_24dp\" android:orderInCategory=\"1\"/&gt; &lt;item android:title=\"@string/favorites\" android:id=\"@+id/main_favorites\" android:icon=\"@drawable/ic_favorite_white_24dp\" android:orderInCategory=\"2\"/&gt; &lt;item android:title=\"@string/nearby\" android:id=\"@+id/main_nearby\" android:icon=\"@drawable/ic_near_by_white_24dp\" android:orderInCategory=\"3\"/&gt;&lt;/menu&gt; 4.回到layout在BottomNavigationView的屬性中添加menu layout: 12345&lt;android.support.design.widget.BottomNavigationView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"?android:attr/windowBackground\" app:menu=\"@menu/bottom_navigation_menu\"/&gt; 運行效果如下： Customize the Bottom Navigation接下來我們要改變BottomNavigationView被選中文字/圖示顏色，包含BottomNavigationView的背景。 BottomNavigationView預設選中的顏色是當前Theme中的color primary，也就是跟Toolbar顏色一至 1.首先建立一個新style，並自定義color primary的顏色 style: 123&lt;style name=\"BottomNavigationTheme\" parent=\"Widget.Design.BottomNavigationView\"&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorBottomNavigation&lt;/item&gt;&lt;/style&gt; 2.回到layout在BottomNavigationView的屬性中添加上剛剛創建的style layout: 123456&lt;android.support.design.widget.BottomNavigationView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"?android:attr/windowBackground\" app:menu=\"@menu/bottom_navigation_menu\" app:theme=\"@style/BottomNavigationTheme\"/&gt; 運行效果如下： 變更BottomNavigationView的背景圖案可以加入屬性： 1app:itemBackground=\"@color/colorCustomize\" 變更BottomNavigationView的圖示顏色可以加入屬性： 1app:itemIconTint=\"@color/colorCustomize\" 變更BottomNavigationView的文字顏色可以加入屬性： 1app:itemTextColor=\"@color/colorCustomize\" Add an On-click Listener to the Bottom Navigation監聽BottomNavigationView的點擊事件，在代碼中呼叫setOnNavigationItemSelectedListener()方法 java: 123456789101112bottomNavigationView.setOnNavigationItemSelectedListener(new BottomNavigationView.OnNavigationItemSelectedListener() { @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) { switch (item.getItemId()) { case R.id.main_recents: return true; case R.id.main_favorites: return true; case R.id.main_nearby: return true; } return false; } }); 運行效果如下： 參考資料：Android BottomNavigationViewMaterial Design Bottom navigation","link":"/Blog/2018/01/23/MaterialDesign-Android-Bottom-Navigation/"},{"title":"[MaterialDesign] Android ViewPager","text":"IntroductionViewPager是在Android平台上很常見的組件之一，常用於需要左右滑動的視圖設計上，接下來我們就直接介紹如何創建一個ViewPager Create a ViewPager1.在Layout上添加ViewPager layout: 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v4.view.ViewPager android:layout_width=\"match_parent\" android:layout_height=\"220dp\" android:id=\"@+id/viewpager_id\"/&gt;&lt;/RelativeLayout&gt; 2.創建一個item view layout: 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.AppCompatTextView android:layout_width=\"match_parent\" android:layout_height=\"220dp\" android:id=\"@+id/textView_id\" android:text=\"1\" android:gravity=\"center\" android:textSize=\"60sp\" android:textStyle=\"bold\"/&gt;&lt;/LinearLayout&gt; 3.activity添加ViewPager Adapter java: 123456789101112131415161718public class MainActivity extends AppCompatActivity { private ViewPager viewPager; private ViewPagerAdapter pagerAdapter; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); viewPager = findViewById(R.id.viewpager_id); pagerAdapter = new ViewPagerAdapter(this); viewPager.setAdapter(pagerAdapter); }} 3.ViewPagerAdapter是繼承自PagerAdapter java: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ViewPagerAdapter extends PagerAdapter { private Context context; LayoutInflater inflater; public ViewPagerAdapter(Context context) { this.context = context; } public String[] pageNames = { \"Page 1\", \"Page 2\", \"Page 3\", \"Page 4\", }; /** * item 數量 * */ @Override public int getCount() { return pageNames.length; } @Override public boolean isViewFromObject(@NonNull View view, @NonNull Object object) { return (view == object); } /** * 添加 item * */ @NonNull @Override public Object instantiateItem(@NonNull ViewGroup container, int position) { inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); // 創建 item view View view = inflater.inflate(R.layout.viewpager_item_layout,container,false); // 取出 ImageView TextView txt = view.findViewById(R.id.textView_id); // 綁定視圖資源 txt.setText(pageNames[position]); //添加item view 到 ViewPager container.addView(view); return view; } /** * 移除 item * */ @Override public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) { container.removeView((LinearLayout)object); }} 運行效果如下： 參考資料：Android Using ViewPager for Screen Slides","link":"/Blog/2018/01/25/MaterialDesogn-Android-ViewPager/"},{"title":"[MaterialDesign] Android CoordinatorLayout","text":"IntroductionCoordinatorLayout，字面上翻譯過來是一個協調者佈局，官方解釋為它是一個超級FrameLayout。大部分使用場景中都搭配AppbarLayout、CollapsingToolbarLayout、Toolbar來使用，導致在不知不覺中，大家也有可能認為CoordinatorLayout只能跟這幾個佈局一起使用。其實CoordinatorLayout的功能可不止於此，本文就簡單介紹CoordinatorLayout的強大功能 CoordinatorLayout最主要兩的作用1.當作根佈局2.當作主要容器，協調一個或多個子View行為 接下來我們來看看範例： 可以看到上圖佈局中有兩個Button1、Button2，移動Button1，Button2也會跟著移動。 如果不使用CoodinatorLayout來實現，那麼兩個Button就必須相互持有，然後再onTouchEvent裡做判斷，如果需要更多的View根據Button1的移動，做出相應的響應，實現起來除了耦合度很高，要寫出完整的判斷是也相當不容易。 BehaviorsCoordinatorLayout使用核心就是Behaviors，透過Behaviors可以執行你訂製的動作，在Behaviors中，有兩種角色1.Dependency指的是Behaviors依賴的View，如上圖中的Button12.Child指的是要執行Behaviors動作的子View，如上圖的Button2 接下來我們來實作Behavior去繼承CoordinatorLayout.Behavior，泛行參數T也就是我們要執行動作的View類，然後實現兩種方法。 12345678910111213@Override public boolean layoutDependsOn(CoordinatorLayout parent, T child, View dependency) { // 判斷 child 是否依賴 Dependency // 返回 false 表示 child 不依賴 Dependency return super.layoutDependsOn(parent, child, dependency); }@Override public boolean onDependentViewChanged(CoordinatorLayout parent, T child, View dependency) { // child 具體要執行的行為 // 當 Dependency 發生變化時(位置、寬、高等)會執行此方法 // 返回 true 表示 child 要作出相應的變化，否則 false return super.onDependentViewChanged(parent, child, dependency); } 有了上述的觀念後接下來實作MyBehavior 1234567891011121314151617181920212223242526272829public class MyBehavior extends CoordinatorLayout.Behavior&lt;Button&gt; { public MyBehavior(Context context, AttributeSet attrs) { super(context, attrs); } @Override public boolean layoutDependsOn(CoordinatorLayout parent, Button child, View dependency) { // 如果依賴是 CustomButton 的實例，返回 true return dependency instanceof CustomButton; } @Override public boolean onDependentViewChanged(CoordinatorLayout parent, Button child, View dependency) { // 根據 dependency 的位置變化，設置 Button 的位置 int top = dependency.getTop(); setPosition(child, top); return true; } private void setPosition(View view, int y) { CoordinatorLayout.MarginLayoutParams layoutParams = (CoordinatorLayout.MarginLayoutParams)view.getLayoutParams(); layoutParams.topMargin = y; view.setLayoutParams(layoutParams); }} 在Layout裡添加自訂義的MyBehavior，Button就會依照Dependency(CustomButton)的變化，作出相應的行為 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"net.nickchen45.coordinatorlayout.MainActivity\"&gt; &lt;android.support.v7.widget.AppCompatButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/button_two\" android:background=\"@color/teal_500\" android:textColor=\"@android:color/white\" android:layout_marginTop=\"0dp\" android:layout_gravity=\"right\" app:layout_behavior=\"net.nickchen45.coordinatorlayout.MyBehavior\"/&gt; &lt;net.nickchen45.coordinatorlayout.CustomButton android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/button_one\" android:background=\"@color/light_blue_500\" android:textColor=\"@android:color/white\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 就算增加一個Button3，也是輕而易舉 參考資料：Android CoordinatorLayoutAndroid CoordinatorLayout.Behavior","link":"/Blog/2018/02/05/MaterialDesign-Android-CoordinatorLayout/"},{"title":"[MaterialDesign] Android AppBarLayout","text":"IntroductionAppBarLayout顧名思義，就是設計在導航欄(Toolbar)、頂部頁籤欄(TabLayout)一起使用，來達成一些Material Design風格的一些滑動交互效果。 AppBarLayout本質上是一個垂直的LinearLayout，不過為了實現滑動交互的效果，因此嚴重依賴於CoordinatorLayout，如果在別的ViewGroup裡，則無法發揮AppBarLayout大部分的功能。 AppBarLayout同時要求Child明確的設置各自的AppBarLayout.ScrollingViewBehavior，在代碼中可以使用setScrollFlags(int)方法，在佈局中可以使用app:layout_scrollFlags屬性。 設定scrollFlags，必須使用AppBarLayout.LayoutParams中已經定義好的五個常量：SCROLL_FLAG_SCROLLSCROLL_FLAG_ENTER_ALWAYSSCROLL_FLAG_ENTER_ALWAYS_COLLAPSEDSCROLL_FLAG_EXIT_UNTIL_COLLAPSEDSCROLL_FLAG_SNAP 接下來我們將一一介紹這些flag的不同 scrollChild View跟滾動事件有直接的關係，也就是說只要手指一滑動，AppBar必定會隨著滑動往上推，或滑動到頂部顯示，這邊有兩點要注意一下。 第一點:如果設置其他的Flag，必須伴隨著使用SCROLL_FLAG_SCROLL才有作用。第二點:在AppBarLayout裡這個Child View，前面沒有任何Child View設置這個值，那麼這個Child View設置將失去任何作用 第一點稍後做說明，第二點的意思如下圖所示: 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"net.nickchen45.appbardemo.MainActivity\"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/appbar_id\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/child_view\" android:textSize=\"22sp\" android:textColor=\"@android:color/white\" android:gravity=\"center\" app:layout_scrollFlags=\"scroll\"/&gt; &lt;android.support.v7.widget.Toolbar android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:id=\"@+id/toolbar_id\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; ...&lt;/android.support.design.widget.CoordinatorLayout&gt; 大家可以看到AppBarLayout裡，有兩個Child View，第二個Child View(Toolbar)，前面有一個Child View(TextView)，且設置著app:layout_scrollFlags=”scroll”。運行效果如下: 如果把第一個Child View(TextView)的Flag移除，並在第二個Child View(Toolbar)中設置，由於第一個Child View沒有設置任何Flag，所以第二個Child View(TextView)即使設置Flag也沒有效果 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"net.nickchen45.appbardemo.MainActivity\"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/appbar_id\"&gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"@string/child_view\" android:textSize=\"22sp\" android:textColor=\"@android:color/white\" android:gravity=\"center\"/&gt; &lt;android.support.v7.widget.Toolbar android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:id=\"@+id/toolbar_id\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\" app:layout_scrollFlags=\"scroll\"/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; ...&lt;/android.support.design.widget.CoordinatorLayout&gt; 運行效果如下: enterAlways在app:layout_scrollFlags設置此屬性，與前者scroll對比，前者是先滾動 Scrolling View，後者是先滾動 Child View，當優先滾動的一方全部顯示後，另一方才會開始滾動 在AppBarLayout的Child View中設置屬性，前面有說明，除了scroll之外其他的Flag，都需搭配scroll使用 1app:layout_scrollFlags=\"scroll|enterAlways\" 運行效果如下: enterAlwaysCollapsedenterAlways的附加flag，向下滾動時，先會顯示Child View的最小高度，等待ScrollView滑至頂部時，Child View再向下滾動，直到完全顯示 需要定義高度、最小高度、Flag等屬性 123android:layout_height=\"200dp\"android:minHeight=\"56dp\"app:layout_scrollFlags=\"scroll|enterAlways|enterAlwaysCollapsed\" 運行效果如下: exitUntilCollapsed當發生向上滾動事件時，Child View會退出螢幕外至保留最小高度，向下滑動到頂部時，Child View才會向下滾動，直到完全顯示 123android:layout_height=\"200dp\"android:minHeight=\"56dp\"app:layout_scrollFlags=\"scroll|exitUntilCollapsed\" 運行效果如下: snapsnap簡單理解，就是child view有一個滾動的吸附效果，當child view滾動達到一定比例，即使手指放開，也會自動滾動到全部顯示，反之則會退出螢幕 12android:layout_height=\"200dp\"app:layout_scrollFlags=\"scroll|snap\" 運行效果如下: 參考資料：AppBarLayoutAppBarLayout.LayoutParams","link":"/Blog/2018/02/07/MaterialDesign-Android-AppBarLayout/"},{"title":"[MaterialDesign] Android Collapsing Toolbar Layout","text":"IntroductionCollapsingToolbarLayout是被設計為AppBarLayout的子類，用於完成一些折疊的UI視覺效果。CollapsingToolbarLayout的功能大概有以下幾點： Collapsing title折疊的Title文字效果，顧名思義在AppBar，完全展開時，會顯示比較大的字型，不過當滑動在螢幕外時，字體會在摺疊動畫結束後，顯示比較小的字型。顯示的文字可以特過屬性setTitle(CharSequence)設置，文字的樣式，可以透過collapsedTextAppearance與expandedTextAppearance兩個屬性調整。 Content scrim當Appbar滑動到一定的程度時，所顯示/隱藏的主體顏色，即Toolbar顏色。可以特過setContentScrim(Drawable) Status bar scrim跟Content scrim相同，不過是狀態列的顏色，可以特過屬性setStatusBarScrim(Drawable)設置，不果只有在Android系統版本5.0以上，並且設定fit system windows時有效果 Parallax scrolling children子類別可以在滾動時選擇，是否以”視差”的方式跟隨滾動，可以透過屬性layout_collapseMode=”parallax”設定 Add the Design Library再使用CollapsingToolbarLayout前，必須先將Design Library加入專案中。在File -&gt; Project Structure -&gt; Dependencles 下新增 Create a Collapsing Toolbar LayoutChange the Default App Theme接下來我們必須創建自己的Toolbar，首先將style.xml裡的AppTheme改為NoActionBar，此舉將讓每頁Activity預設無Action Barsytle.xml: 1234567891011&lt;resources&gt; ... &lt;!-- Base application theme. --&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt; ...&lt;/resources&gt; Create a Toolbar接下來在Activity.xml裡，新增一個Toolbar，前面我們有介紹過，CollapsingToolbarLayout是被設計用來實現AppBarLayout折疊UI效果的子類，所以我們必須在AppBarLayout下創建它，並在CollapsingToolbarLayout裡新增一張圖片，來作為AppBarLayout展開時的背景。 如果還不清楚CoordinatorLayout與AppBarLayout，可以點連結查看 layout: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:fitsSystemWindows=\"true\" tools:context=\"net.nickcode4fun.collapsingtoolbarlayout.MainActivity\"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/app_bar_layout\" android:fitsSystemWindows=\"true\" android:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/collpasingToolbarLayout\" android:fitsSystemWindows=\"true\" app:contentScrim=\"?attr/colorPrimary\" app:expandedTitleMarginEnd=\"64dp\" app:expandedTitleMarginStart=\"48dp\" app:layout_scrollFlags=\"scroll|exitUntilCollapsed\"&gt; &lt;ImageView android:layout_width=\"match_parent\" android:layout_height=\"300dp\" android:fitsSystemWindows=\"true\" android:src=\"@drawable/bg_appbar\" android:scaleType=\"fitXY\" app:layout_collapseMode=\"parallax\" android:contentDescription=\"@string/firework\" /&gt; &lt;android.support.v7.widget.Toolbar android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:id=\"@+id/toolbar\" app:layout_collapseMode=\"parallax\" /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 並在Activity.java中，設置Toolbar 12345678public class MainActivity extends AppCompatActivity { @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setSupportActionBar((Toolbar) findViewById(R.id.toolbar)); }} 運行效果如下： 參考資料：Android CollapsingToolbarLayout","link":"/Blog/2018/02/21/MaterialDesign-Android-Collapsing-Toolbar-Layout/"},{"title":"[Android] Create Deep Links to App Content","text":"Introduction何謂Deep Links: Deep Links是指透過指定連結，來喚起指定應用，並可以向指定頁面傳送數據，它使我們應用程式之間產生了關係，讓應用不再孤立，優化了使用者體驗。 Deep Links採用Uri Scheme的方式來實現，如果不太了解Uri Scheme的人，可以查詢維基百科下面就簡單展示一下Uri Scheme組成: 1234567891011 hierarchical part ┌───────────────────┴─────────────────────┐ authority path ┌───────────────┴───────────────┐┌───┴────┐ abc://username:password@example.com:123/path/data?key=value&amp;key2=value2#fragid1 └┬┘ └───────┬───────┘ └────┬────┘ └┬┘ └─────────┬─────────┘ └──┬──┘scheme user information host port query fragment urn:example:mammal:monotreme:echidna └┬┘ └──────────────┬───────────────┘scheme path 下面我們來實做一下，如何在`Android`上實現`Deep Links`。 Add intent filters for incoming links首先當我們在點擊連結或 Web URI 的意圖時，Android系統會依序執行以下操作，直到意圖成功被Handle 使用者指定的可以處理URI的應用程式 打開安裝的應用中，可以處理此URI的應用 允許用戶選擇可以Handle此URI的應用程式 所以為了讓URI成功被Handle，我們必須在Android專案目錄裡manifest文件下，指定activity標籤中，新增intent-filter 12345678910111213141516171819202122232425262728&lt;application...&gt; &lt;activity ...&gt; &lt;intent-filter&gt; &lt;!--指定Action View的意圖操作，此intent-filter才可以從Google Search被搜尋--&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;!--類別需包含BROWSABLE，Web瀏覽器才可以訪問intent-filter--&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;!--還必須包含DEFAULT，此允許應用可以響應隱式意圖，讓URI被過濾時啟動你的應用--&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;!--data表示每一個解析URI的格式，可以添加多個解析格式，但每一個最少要包含一個scheme屬性--&gt; &lt;!-- Accepts URIs that begin with &quot;http://nickcode4fun.net/archives” --&gt; &lt;data android:scheme=&quot;http&quot; android:host=&quot;nickcode4fun.net&quot; android:pathPrefix=&quot;/archives&quot; /&gt; ... &lt;data.../&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; Read data from incoming intents你可以在系統啟動你的Activity時，透過Intent中的getData()與getAction()方法，取得與意圖相關的資訊。 123456789@Overridepublic void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); Intent intent = getIntent(); String action = intent.getAction(); Uri data = intent.getData();} 運行效果如下: 那麼如何取得URL攜帶的Data呢？Ex: http://nickcode4fun.net/archives?type=1&amp;id=10001 1234567891011121314151617181920212223242526@Overridepublic void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.main); Intent intent = getIntent(); String action = intent.getAction(); Uri uri = intent.getData(); assert uri != null; String scheme = uri.getScheme(); String host = uri.getHost(); String path = uri.getPath(); String query = uri.getQuery(); String type = uri.getQueryParameter(&quot;type&quot;); String id = uri.getQueryParameter(&quot;id&quot;); final String msg = &quot;action: &quot; + action + &quot;\\n&quot; + &quot;uri: &quot; + uri + &quot;\\n&quot; + &quot;scheme: &quot; + scheme + &quot;\\n&quot; + &quot;host: &quot; + host + &quot;\\n&quot; + &quot;path: &quot; + path + &quot;\\n&quot; + &quot;query: &quot; + query + &quot;\\n&quot; + &quot;type: &quot; + type + &quot;\\n&quot; + &quot;id: &quot; + id + &quot;\\n&quot;;} 運行效果如下:現在Android Studio提供圖形化介面來管理Deep Links，詳情可以參考下面連結 Select Tools &gt; App Links Assistant. Click Open URL Mapping Editor and then click Add at the bottom of the URL Mapping list to add a new URL mapping. 參考資料：Create Deep Links to App ContentAdd Android App Links","link":"/Blog/2018/10/27/Android-Create-Deep-Links-to-App-Content/"},{"title":"[Android] Bottom Sheets","text":"IntroductionBottomSheets是Design Support Library23.2版本引入的一個底部彈出框控件，通常用於顯示主畫面之外的額外訊息，默認是隱藏，或只顯示一小部分，並可以透過代碼或是手勢，來控制視圖是否要展開，本文主要是介紹如何使用BottomSheets，更多介紹可以查看Material-ComponentsMaterial-Design The type of bottom sheetsBottomSheets可以分為以下兩種類型。 Persistent Bottom Sheet為主畫面的一份部內容，默認被隱藏，只會顯示出一部分的內容，其高度elevation與主畫面為同一級別，簡單來說，此類型與另一項最大的區別，是在BottomSheets全部展開時，主畫面仍可以操作。Ex: 可以在app中看到其應用場景(material.io) Modal Bottom Sheet通常用來取代menu或是dialog，此類型擁有比主畫面更高的高度elevation，也就是說，它並不是與主畫面處於同一級，而是像覆蓋在主畫面之上，與另一類最大的不同，就是他會阻止使用者與主畫面交互行為。Ex: 可以在app中看到其應用場景(material.io)接下來來看看，如何在代碼中實現。 Import Design Library在app目錄下，build.gradle文件中，添加依賴庫 12345678android { // ... }dependencies { // ... implementation 'com.android.support:design:28.0.0'} Add Bottom Sheets首先，我們來實現，如何在主畫面上，添加一個BottomSheets。 Create Bottom Sheets Layout在layout資源目錄下，創建一個新layout，並在xml的ViewGroup中，添加下面幾個屬性 behavior_hideable: 是否可以隱藏此視圖 behavior_peekHeight: 添加在主畫面時，未展開狀態下，保留的高度 layout_behavior: 定義了這個屬性，相當於告訴了CoordinatorLayout，這是一個BottomSheets，@string/bottom_sheet_behavior是定義在支持庫中的字符串，等效於android.support.design.widget.BottomSheetBehavior。 bottom_sheets.xml，如下 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/bottom_sheet\" ... app:behavior_hideable=\"true\" app:behavior_peekHeight=\"48dp\" app:layout_behavior=\"android.support.design.widget.BottomSheetBehavior\"&gt; ... &lt;/LinearLayout&gt; Add Bottom Sheets to View緊接著在主畫面中，添加bottom_sheets.xml，這邊要注意的一點是，Bottom Sheets Behavior是CoordinatorLayout的子類，所以在添加到主畫面時，務必注意主畫面的ViewGroup是否為CoordinatorLayout。更多CoordinatorLayout請參考另一篇文章[MaterialDesign] Android CoordinatorLayout 主畫面layout.xml下添加，如下 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\".MainActivity\"&gt; &lt;!-- Adding main view content --&gt; &lt;include layout=\"@layout/activity_main\" /&gt; &lt;!-- Adding bottom sheet after main content --&gt; &lt;include layout=\"@layout/bottom_sheet\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; activity_main.xml佈局： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:paddingEnd=\"16dp\" android:paddingStart=\"16dp\"&gt; &lt;android.support.v7.widget.AppCompatButton android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"5dp\" android:onClick=\"showBottomSheet\" android:text=\"Bottom Sheet\" /&gt;&lt;/LinearLayout&gt; `MainActivity.kt`代碼如下: 1234567891011121314151617181920212223class MainActivity : AppCompatActivity() { lateinit var bottomBehavior: BottomSheetBehavior&lt;View&gt; lateinit var bottomSheet: View override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.layout) bottomSheet = findViewById&lt;View&gt;(R.id.bottom_sheet) bottomBehavior = BottomSheetBehavior.from(bottomSheet) } fun showBottomSheet(v: View) { setBottomViewVisible(bottomBehavior.state != BottomSheetBehavior.STATE_EXPANDED) } private fun setBottomViewVisible(isShow: Boolean) { if (isShow) bottomBehavior.state = BottomSheetBehavior.STATE_EXPANDED else bottomBehavior.state = BottomSheetBehavior.STATE_COLLAPSED }} Control Persistent Bottom Sheets我們透過取得BottomSheets的Behavior來控制BottomSheets的狀態。BottomSheets總共有5種狀態 STATE_COLLAPSED: 默認折疊狀態，只顯示底部一小部分佈局，顯示高度可以通過app:behavior_peekHeight設置。 STATE_DRAGGING: 過度狀態，此時BottomSheets正在向上或向下拖動。 STATE_SETTLING: 手勢離開視圖，自由滑動到停止的一小段時間 STATE_EXPANDED: 佈局全展開狀態。 STATE_HIDDEN: 默認無此狀態(可通過：app:behavior_hideable啟用此狀態)，用戶能通過下向滑動，完全隱藏BottomSheets。 在代碼中實踐 1BottomSheetBehavior.setState(BottomSheetBehavior.STATE_COLLAPSED)； BottomSheetDialog為Modal Bottom Sheet的一種，與Persistent Bottom Sheets最大的不同點就是會阻止，用戶與主畫面交互，接下來讓我們看看如何在代碼中實踐。 1234val view: View = layoutInflater.inflate(R.layout.bottom_sheet, null)val dialog: BottomSheetDialog = BottomSheetDialog(this)dialog.setContentView(view)dialog.show() 佈局與上面layout.bottom_sheet.xml相同。效果如下: BottomSheetDialogFragment與BottomSheetDialog相同，會阻止主畫面的交互行為。實踐起來也很簡單。 Extends BottomSheetDialogFragment首先，創建一個class繼承BottomSheetDialogFragment BottomSheetFragment.kt: 1234567891011class BottomSheetFragment : BottomSheetDialogFragment() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) } override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { // Inflate the layout for this fragment return inflater.inflate(R.layout.bottom_sheet, container, false) }} 佈局與上面layout.bottom_sheet.xml相同。接著在主畫面代碼中添加: 12val bottomSheetFragment = BottomSheetFragment()bottomSheetFragment.show(supportFragmentManager, bottomSheetFragment.tag) 效果如下: 參考資料：androidhiveMaterialDesign-Bottom Sheets","link":"/Blog/2018/11/16/Android-Bottom-Sheets/"},{"title":"[Android] Gaussian blur Effect","text":"Intrdoction本篇文章來介紹，如何在Android上，簡單實現高斯模糊（Gaussian blur)效果。又稱毛玻璃效果或磨砂效果。透果使用Google提供的RenderScriptApi，一個強大的圖片處理框架，幫助Android開法者專注於圖片處理算法的邏輯，而不是處理圖像複雜的計算。 RenderScriptRenderScript根據Android官方網站的介紹，在計算的效率上，能充分利用GPU，CPU的計算能力，所以在編寫代碼的時候，毋須擔心具體硬件的不同，都能寫出具高效率的代碼。此篇文章實現的Gaussian blur效果，只是使用到了RenderScript其中一個操作類ScriptIntrinsicBlur，RenderScriptApi的強大遠不及此，更詳情可以參考 Android 官網 RenderScript介紹 添加Api依賴庫添加此依賴庫也很簡單，只要在app/build.gradle文件，在android/defaultConfig配置中添加兩行代碼： 12345678android { ... defaultConfig { ... renderscriptTargetApi 18 renderscriptSupportModeEnabled true }} 代碼實現起來也很簡單，如下： 12345678910111213141516171819202122232425262728293031323334public Bitmap blurBitmap(Bitmap bitmap) { //Let's create an empty bitmap with the same size of the bitmap we want to blur Bitmap outBitmap = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888); //Instantiate a new Renderscript RenderScript rs = RenderScript.create(getApplicationContext()); //Create an Intrinsic Blur Script using the Renderscript ScriptIntrinsicBlur blurScript = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); //Create the Allocations (in/out) with the Renderscript and the in/out bitmaps Allocation allIn = Allocation.createFromBitmap(rs, bitmap); Allocation allOut = Allocation.createFromBitmap(rs, outBitmap); //Set the radius of the blur: 0 &lt; radius &lt;= 25 blurScript.setRadius(25.0f); //Perform the Renderscript blurScript.setInput(allIn); blurScript.forEach(allOut); //Copy the final bitmap created by the out Allocation to the outBitmap allOut.copyTo(outBitmap); //recycle the original bitmap bitmap.recycle(); //After finishing everything, we destroy the Renderscript. rs.destroy(); return outBitmap; } 透過設置模糊半徑radius大小來控制圖片的清晰度。這邊值得注意的是ScriptIntrinsicBlur只支援API17以上版本，為了兼容舊版，Google提供了android.support.v8.renderscript兼容包，使用時只要引入該兼容包下相關的類別即可。效果如下: 參考資料：Android RenderScript維基百科介紹 RenderscriptCSDN-huachao1001部落格","link":"/Blog/2018/12/01/Android-Gaussian-blur-Effect/"},{"title":"物件導向設計原則(SOLID)#1 - Single Responsibility Principle","text":"物件導向設計本身就具有封裝、繼承、多型、抽象這些特性。 那麼是否掌握這些特性，就可以寫出具備閱讀性、維護性、擴充性的程式碼呢？ 非也… 在物件導向開發軟體的過程中，遵守Robert C. Martin提出的物件導向設計的五個原則(SOLID)。這樣會更容易開發出易維護與可擴展的系統。 縮寫 英文全名 中譯 SRP Single Responsibility Principle 單一職責原則 OCP Open Closed Principle 開放封閉原則 LSP Liskov Substitution Principle 里氏替換原則 ISP Interface Segregation Principles 介面隔離原則 DIP Dependency Inversion Principle 依賴反轉原則 Single Responsibility對於不熟的開發者，很常犯的錯誤就是把很多功能寫在同一個 class，雖然讓這個 class 擁有許多功能，但也大大增加了維護的困難。整體來說Z&gt;B(利大於弊)。 那麼要做的是很簡單，讓 class 一次只做一件事，並移除與這件事情無關的程式碼和變數。 Do one thing and do it well. Example1234567891011121314151617181920212223242526public class StockReporter { /** * 查詢股票更新時間 * * @param symbol 股市代號 */ public String getStockUpdateTime(String symbol) { Stock stock = queryStockFromServer(symbol); return stock.getTime(); } /** * 從服務器取得股票資料 * * @param symbol 股市代號 */ public Stock queryStockFromServer(String symbol) { // 模擬從 API 取得資料 return new Stock( \"ATA CREATIVITY GLOBAL - ADR\", \"AACG\", 1.16f, \"2020-02-18\"); }} 這個範例很明顯違反了 Single Responsibility 原則 要改變資料取得方式，必須修改這個 Class Solution改變資料取得方式12345678910111213/*** 從服務器取得股票資料** @param symbol 股市代號*/public Stock queryStockFromServer(String symbol) { // 模擬從 API 取得資料 return new Stock( \"ATA CREATIVITY GLOBAL - ADR\", \"AACG\", 1.16f, \"2020-02-18\");} 使用 Repository 來取得資料123456789101112131415class Repository { /** * 從服務器取得股票資料 * * @param symbol 股市代號 */ public Stock queryStockFromServer(String symbol) { // 模擬從 API 取得資料 return new Stock( \"ATA CREATIVITY GLOBAL - ADR\", \"AACG\", 1.16f, \"2020-02-18\"); } } 因此，StockReporter 修改如下 123456789101112131415161718public class StockReporter { private Repository repository; public StockReporter(Repository repository) { this.repository = repository; } /** * 查詢股票更新時間 * * @param symbol 股市代號 */ public String getStockUpdateTime(String symbol) { Stock stock = repository.queryStockFromServer(symbol); return stock.getTime(); }} 讓取得資料的相依關係透過 Repository 來處理 如此一來，當我們要更改取得資料這段邏輯的時候，便不需要更改 StockReporter 了。 最後 StockReporter 使用方式如下： 1234567 public void use() { StockReporter reporter = StockReporter(new Repository(); String updateTime = reporter.getStockUpdateTime(\"AACG\"); System.out.println(\"AACG update time: \" + updateTime); }","link":"/Blog/2020/02/18/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87-SOLID-1-Single-Responsibility-Principle/"},{"title":"物件導向設計原則(SOLID)#2 - Open Closed Principle","text":"Open Closed Principle (OCP) 藉由增加新的程式碼來擴充系統的功能，而不是藉由修改原本已經存在的程式碼來擴充系統的功能。 在軟體開發中，對於擴展是開放，對於修改是封閉，用來避免改A壞B的情形，講白了就是不去動舊的程式碼，而是對於新增的程式碼補上測試就好。 什麼意思呢？ Example假如現在要開發第三平台登入功能，以前程式碼可能寫成這樣。 1234567891011public class AuthController { public void login(Auth authData) { if (authData.type.equals(\"facebook\")) { // 實作 facebook 登入 } else if (authData.type.equals(\"google\")){ // 實作 google 登入 } else { throw new IllegalStateException(); } }} 但如果再增加另一個第三方登入，則會破壞原本的結構。使用OCP的寫法會這樣。 123456789101112131415161718192021222324interface ISocial { void login(Auth authData);}class Facebook implements ISocial { @Override public void login(Auth authData) { // 實作 facebook 登入 }}class Google implements ISocial { @Override public void login(Auth authData) { // 實作 google 登入 }}class OtherSocial implements ISocial { @Override public void login(Auth authData) { // 實作其他第三方登入 }} 接著重構AuthController 12345public class AuthController { public void login(ISocial social, Auth authData) { social.login(authData); }} 如此一來，就算新增了其他第三方平台登入方式，也不會去改動到原本的程式碼","link":"/Blog/2020/02/19/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E8%A8%AD%E8%A8%88%E5%8E%9F%E5%89%87-SOLID-2-Open-Closed-Principle/"},{"title":"[Material Design] Android Navigation Drawer(一)","text":"IntroductionNavigation Drawer 是一個隱藏在 APP 畫面左邊的面板，通常會用在應用的主頁，用以顯示應用主要的功能項，預設情況下通常是隱藏在左邊，使用者可以透過手指，在螢幕上由左向右滑動，把 Navigation drawer 呼叫顯示出來。 可以先參考Material Design官網的圖片 通常 Navigation Drawer 可以由幾部分組成： HeaderHeaders 通常用來顯示圖片，或聯絡資訊，當然這並不是所有的 APP 都這樣做 Navigation View在 Header 下面的區塊，稱為 Navigation View ，我們可以自定義 items 包含 icon 在這裡，這些 items 將會組成我們的 Navigation Drawer Munu Create a Navigation Drawer在創建 Activity 時，Android Studio 有提供我們快速創建 Navigation Drawer Activity ，不過在本篇文章中，我們選擇 Empty Activity 創建 Add Design Library to Our Project在創建 Navigation Drawer 的第一步，我們必須先確認此專案有 import Design Library，可以在 File -&gt; Project Structure -&gt; Dependencles 下新增。 新增完在 build.gradle 下，注意版本需與 appcompat-v7 的版本一至 Remove default toolbar form application進入 res -&gt; values 目錄下，打開 style.xml file，把 AppTheme 改為 1234567891011&lt;resources&gt; &lt;!-- Base application theme. --&gt; &lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;!-- Customize your theme here. --&gt; &lt;item name=\"colorPrimary\"&gt;@color/colorPrimary&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/colorPrimaryDark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/colorAccent&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 此舉的目的是，移除 App 預設的 toolbar，緊接著我們在 activity layout 使用自定義的 toolbar 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"@color/colorPrimary\" app:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"/&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 回到 activity 中，使用 setSupportActionBar method 設定替換成自定義的 toolbar 12345678910111213public class MainActivity extends AppCompatActivity { Toolbar toolbar; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); toolbar = findViewById(R.id.toolbar); setSupportActionBar(toolbar); }} 執行後可以看到效果 Create Drawer Layout在這邊我們要創建一個新 layout，用以創建 Navigation Drawer，並把根佈局替換成，support.v4 包下面的 DrawerLayout 緊接著我們在 DrawerLayout 添加屬性 id 與 fitsSystemWindows = true。fitsSystemWindows 為 ture 代表你的 DrawerLayout size 會與你的 Activity size 一至 12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/drawer_layout\" android:fitsSystemWindows=\"true\"&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 然後我們再 DrawerLayout 裡面，引用 Design Library 中的 Navigation View 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/drawer_layout\" android:fitsSystemWindows=\"true\"&gt; &lt;android.support.design.widget.NavigationView android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:id=\"@+id/navigation_view\" android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 其中，layout_gravity=”start” 表示你的 NavigationView 會位於 Activity 的左側。 接下來我們要把定義好的 DrawerLayout 設為 Activity 預設的 Layout，這表示當 Application 啟動 此 activity 頁面時，此 DrawerLayout 將會被預加載。 回到我們的 Activity，將 setContentView Method 中的 layout 替換成剛剛新增的 navigation_drawer.xml 1234567891011121314public class MainActivity extends AppCompatActivity { Toolbar toolbar; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 這邊替換成 navigation_drawer setContentView(R.layout.navigation_drawer); toolbar = findViewById(R.id.toolbar); setSupportActionBar(toolbar); }} 然後再回到 navigation_drawer.xml 下，把原本的 activity_main.xml 用 include tag import 進來 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/drawer_layout\" android:fitsSystemWindows=\"true\"&gt; &lt;include layout=\"@layout/activity_main\"/&gt; &lt;android.support.design.widget.NavigationView android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:id=\"@+id/navigation_view\" android:layout_gravity=\"start\" android:fitsSystemWindows=\"true\"/&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 到了這邊大家可能會有點搞混，目前的畫面結構大概如下圖所示 Create Navigation Drawers Header接下來我們創建，Navigation Drawer Header Layout 文件 Navigation Header 的高度通常是介於 160 ~ 180 dp 之間，接下來我們把 Header 高度定義為 160 dp，並加入 Header Background，當然你也可以放入任何你喜歡圖Header Layout 如下： Add Navigation Drawers Menu我們在完成 Header Layout 後，緊接著我們需要在 res -&gt; menu 下創建 navigation_menu.xml，然後在此 menu 中定義我們的 item 先在 group tag 裡 定義數個 item，checkableBehavior 表示點擊行為的效果反饋，緊接著再完成 group tag 後，新增 item tag 並在裡面再新增一個 menu tag 與裡面的 item 如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;group android:checkableBehavior=\"single\"&gt; &lt;item android:id=\"@+id/inbox_id\" android:icon=\"@drawable/inbox\" android:title=\"@string/inbox\" /&gt; &lt;item android:id=\"@+id/starred_id\" android:icon=\"@drawable/starred\" android:title=\"@string/starred\" /&gt; &lt;item android:id=\"@+id/sent_id\" android:icon=\"@drawable/sent\" android:title=\"@string/sent_mail\" /&gt; &lt;item android:id=\"@+id/drafts_id\" android:icon=\"@drawable/drafts\" android:title=\"@string/drafts\" /&gt; &lt;/group&gt; &lt;item android:title=\"@string/subheader\"&gt; &lt;menu&gt; &lt;item android:id=\"@+id/allmail_id\" android:icon=\"@drawable/allmail\" android:title=\"@string/all_mail\" /&gt; &lt;item android:id=\"@+id/trash_id\" android:icon=\"@drawable/trash\" android:title=\"@string/trash\" /&gt; &lt;item android:id=\"@+id/spam_id\" android:icon=\"@drawable/spam\" android:title=\"@string/spam\" /&gt; &lt;/menu&gt; &lt;/item&gt;&lt;/menu&gt; 再定義完 Navigation Drawers Menu 後，我們把回到 DrawerLayout，並把剛剛定義好的 Header 與 Menu 都加進，NavigationView 的屬性中 緊接著我們回到 Activity 完善以下代碼 12345678910111213141516171819202122public class MainActivity extends AppCompatActivity { Toolbar toolbar; DrawerLayout drawerLayout; NavigationView navigationView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.navigation_drawer); toolbar = findViewById(R.id.toolbar); setSupportActionBar(toolbar); drawerLayout = findViewById(R.id.drawer_layout); navigationView = findViewById(R.id.navigation_view); ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(this, drawerLayout, toolbar, R.string.open_drawer, R.string.close_drawer); drawerLayout.addDrawerListener(toggle); toggle.syncState(); }} 然後就可以在畫面上看到效果了 參考網站:Android DeveloperMaterial Design","link":"/Blog/2017/12/30/MaterialDesign-Android-Navigation-Drawer(%E4%B8%80)/"},{"title":"[Material Design] Android Text Fields","text":"IntroductionText Fields 文本框，是一種允許使用者輸入、編輯、選擇文字的封裝類，常出現在表單中，不過也可以用在 Dialog 或是 搜尋框中。與 TextInputLayout 搭配使用，可以讓你的使用者體驗更佳 在本篇文章中，我們要使用 support.v7 library 下的 AppCompatEditText 與 TextInputLayout 來實現我們下面的數種效果： Add a Text Input Layout to the AppCompat EditTextAdd Design Library To Our Project首先我們先打開 File -&gt; Project structure -&gt; app -&gt; Dependencies，把 design library 添加進來 Add Text Input Layout to our Layout創建一個 TextInputLayout，並把 AppCompatEditText 放到裡面就完成了，運行起來會看到 hint 的文字透過動畫，上移到輸入匡的左上方 xml: 1234567891011121314151617&lt;android.support.design.widget.TextInputLayout android:id=\"@+id/username_text_input_layout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"8dp\" android:layout_marginLeft=\"32dp\" android:layout_marginRight=\"32dp\" android:layout_marginTop=\"32dp\"&gt; &lt;android.support.v7.widget.AppCompatEditText android:id=\"@+id/username_text_field\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/username\" android:inputType=\"text\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; 運行效果如下： 這邊大家可以發現，focus 預設是在第一個 AppCompatEditText 上，如果想改變 focus，只要在第二個 AppCompatEditText tag 結尾加上，&lt; requestFocus /&gt; tag 就可以了 xml: 123456789101112131415161718&lt;android.support.design.widget.TextInputLayout android:id=\"@+id/password_text_input_layout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@id/username_text_input_layout\" android:layout_marginBottom=\"8dp\" android:layout_marginLeft=\"32dp\" android:layout_marginRight=\"32dp\" android:layout_marginTop=\"32dp\"&gt; &lt;android.support.v7.widget.AppCompatEditText android:id=\"@+id/password_text_field\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/password\" android:inputType=\"textPassword\" /&gt;&lt;requestFocus/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; 運行效果如下： 如果我們不想一開始就 focus 在任一個 AppCompatEditText 上，我們可以設定預設 focus 在最外層的 ViewGroup 上。在最外層的 ViewGroup 上，添加兩個屬性 :.* android:focusable=”true”.* android:focusableInTouchMode=”true” xml: 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/activity_main\" android:focusable=\"true\" android:focusableInTouchMode=\"true\"&gt; ...&lt;/RelativeLayout&gt; 運行效果如下： 如果我們還想要，在點擊 AppCompatEditText 以外的地方，移除 AppCompatEditText 的 focus 怎麼辦呢？最直接的解決辦法就是在最外層的 ViewGroup 設定點擊事件就好了，這樣當用戶點擊 AppCompatEditText 以外的地方(其實就是點擊 ViewGroup )，focus 就會移轉到ViewGroup 上。 回到我們的代碼中，新增 ViewGroup 點擊事件 java: 12345678910111213141516public class MainActivity extends AppCompatActivity { RelativeLayout relativeLayout; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); relativeLayout = findViewById(R.id.activity_main); relativeLayout.setOnClickListener(null);// 設定點擊事件 } ...} 運行效果如下： More features of AppCompat EditTextTextInputLayout 還提供一些方便的方法 顯示錯誤訊息可以清楚明暸的回饋給使用者一些錯誤的訊息，比如：輸入必填欄位 xml: 1234567891011121314151617&lt;android.support.design.widget.TextInputLayout android:id=\"@+id/username_text_input_layout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"8dp\" android:layout_marginLeft=\"32dp\" android:layout_marginRight=\"32dp\" android:layout_marginTop=\"32dp\"&gt; &lt;android.support.v7.widget.AppCompatEditText android:id=\"@+id/username_text_field\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/username\" android:inputType=\"text\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; java: 12userTextInputLayout.setErrorEnabled(true);userTextInputLayout.setError(\"please input user name\"); 運行效果如下： 密碼明碼顯示很常見的功能，可以讓使用者在送出密碼前，自己檢查密碼正確性，只要在 TextInputLayout tag 裡添加，app:passwordToggleEnabled=”true”，即可啟用 xml: 12345678910111213141516171819&lt;android.support.design.widget.TextInputLayout android:id=\"@+id/password_text_input_layout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@id/username_text_input_layout\" android:layout_marginBottom=\"8dp\" android:layout_marginLeft=\"32dp\" android:layout_marginRight=\"32dp\" android:layout_marginTop=\"32dp\" app:passwordToggleEnabled=\"true\"&gt; &lt;android.support.v7.widget.AppCompatEditText android:id=\"@+id/password_text_field\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/password\" android:inputType=\"textPassword\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; 運行效果如下： 字元統計提供方便的字數提示，只需要在 TextInputLayout tag 中，添加屬性 app:counterEnabled 及 app:counterMaxLength 就可以了 xml: 1234567891011121314151617181920&lt;android.support.design.widget.TextInputLayout android:id=\"@+id/password_text_input_layout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@id/username_text_input_layout\" android:layout_marginBottom=\"8dp\" android:layout_marginLeft=\"32dp\" android:layout_marginRight=\"32dp\" android:layout_marginTop=\"32dp\" app:counterEnabled=\"true\" app:counterMaxLength=\"10\"&gt; &lt;android.support.v7.widget.AppCompatEditText android:id=\"@+id/password_text_field\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/password\" android:inputType=\"textPassword\" /&gt;&lt;requestFocus/&gt; &lt;/android.support.design.widget.TextInputLayout&gt; 也可以以代碼的方式啟用 java: 12passwordTextInputLayout.setCounterEnabled(true);passwordTextInputLayout.setCounterMaxLength(10); 運行效果如下：超過字數時 改變顏色系統預設正常輸入下是稍微偏紅色，與字元計數器超過自定義限制時，顏色是紫色，我們可以特過宣告 style 的方式來改變外觀 style: 1234567&lt;style name=\"textInputLayoutStyle\" parent=\"AppTheme\"&gt; &lt;item name=\"colorAccent\"&gt;@color/colorTextInputNormal&lt;/item&gt;&lt;/style&gt;&lt;style name=\"characterOverFlowStyle\"&gt; &lt;item name=\"android:textColor\"&gt;@color/colorTextInputError&lt;/item&gt;&lt;/style&gt; 接著將 style 設定到 TextInputLayout 的屬性裡 xml: 12345678910111213141516171819202122&lt;android.support.design.widget.TextInputLayout android:id=\"@+id/password_text_input_layout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@id/username_text_input_layout\" android:layout_marginBottom=\"8dp\" android:layout_marginLeft=\"32dp\" android:layout_marginRight=\"32dp\" android:layout_marginTop=\"32dp\" android:theme=\"@style/textInputLayoutStyle\" app:counterEnabled=\"true\" app:counterMaxLength=\"10\" app:counterOverflowTextAppearance=\"@style/characterOverFlowStyle\"&gt; &lt;android.support.v7.widget.AppCompatEditText android:id=\"@+id/password_text_field\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:hint=\"@string/password\" android:inputType=\"textPassword\" /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; 運行效果如下：正常狀態下，顯示 colorTextInputNormal 顏色超過字數時，顯示 colorTextInputError 顏色 .改變hint的顏色也可以特過 app:hintTextAppearance 方法.改變錯誤訊息的外觀顏色 app:errorTextAppearance 方法設定方法就同設定 app:counterOverflowTextAppearance 與 characterOverFlowStyle 參考網站:Android DeveloperMaterial Design","link":"/Blog/2018/01/07/MaterialDesign-Android-Text-Fields/"},{"title":"[MaterialDesign] Android Tabs","text":"Introduction在Material Design中，Tabs使用頁籤的方式管理不同的畫面，通常位於Toolbar的下方，常與Fragment/ViewPager搭配使用。背景的顏色通常也與Toolbar一致 在常見的使用中，Tabs可以被分為兩種模式1.Fixed在Fixed模式下，每個Tab item的大小都是一致的，也因為大小都一樣，所以在設計上通常放置兩個(含)以上，最多四個item2.Scrollable在Scrollable模式下，Tab item常為4個以上 在Tabs item設計上，不管是Fixed模式或是Scrollable模式，都可以用文字 / 圖案 / 文字+圖案下去設計，接下來我們來實際創建一個Tabs + ViewPager Create a Tab Layout with Text: Fixed Mode添加support:design library使用TabLayout，首先需要把support:design library添加進我們的Project中，在 File -&gt; Project Structure -&gt; Dependencles 下新增。 創建TabLayout在xml裡，創建一個TabLayout，賦予屬性app:tabMode=”fixed”，背景顏色使用跟Toolbar(colorPrimary)顏色一致，接著在下方創建ViewPager app:tabGravity=”fill”表示tabs item會填滿整個TabLayout layout: 1234567891011121314151617181920212223242526272829&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" xmlns:app=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;android.support.v7.widget.Toolbar android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:id=\"@+id/toolbar_id\" android:background=\"@color/colorPrimary\" app:theme=\"@style/ThemeOverlay.AppCompat.Dark.ActionBar\"/&gt; &lt;android.support.design.widget.TabLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/tabLayout_id\" android:layout_below=\"@+id/toolbar_id\" android:background=\"@color/colorPrimary\" app:tabMode=\"fixed\" app:tabGravity=\"fill\"/&gt; &lt;android.support.v4.view.ViewPager android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/viewPager_id\" android:layout_below=\"@+id/tabLayout_id\"/&gt;&lt;/RelativeLayout&gt; 預覽效果如下: Define layouts for the items in TabLayout我們新增Fragment的layout，這些View，會顯示在ViewPager中，同時透過TabLayout的setupWithViewPager()方法，能夠自動產生對應ViewPager內view的tab item。 新增Fragment layoutlayout: 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;android.support.v7.widget.AppCompatTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_centerInParent=\"true\" android:text=\"@string/main_item_one\" android:textSize=\"60sp\" android:textStyle=\"bold\"/&gt;&lt;/RelativeLayout&gt; 預覽效果如下: 接著依序創建layout_item_two與layout_item_three_layout，總共3個layout Create Java class for item layout接下來創建Freagment class java: 1234567891011public class OneFragment extends Fragment { private View view; @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { view = inflater.inflate(R.layout.layout_item_one, container, false); return view; }} 依序創建：layout_item_onelayout_item_twolayout_item_three的Fragment class Create a ViewPager Adapter接下來我們創建ViewPagerAdapter，並繼承FragmentPagerAdapter java: 123456789101112131415161718192021222324252627282930313233public class ViewPagerAdapter extends FragmentPagerAdapter { private List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;(); private List&lt;String&gt; fragmentTitleList = new ArrayList&lt;&gt;(); public ViewPagerAdapter(FragmentManager fm) { super(fm); } @Override public Fragment getItem(int position) { // Fragment return fragmentList.get(position); } @Override public int getCount() { return fragmentList.size(); } @Nullable @Override public CharSequence getPageTitle(int position) { // 取得當前頁的title return fragmentTitleList.get(position); } // 添加Fragment 與 Title 方法 public void addFragment(Fragment fragment, String title) { fragmentList.add(fragment); fragmentTitleList.add(title); }} Setting TabLayout在Adapter創建完成之後，回到Activity，把Fragment加進adapter，並把它與ViewPager綁定 java: 1234567ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager());adapter.addFragment(new OneFragment(), \"ITEM ONE\");adapter.addFragment(new TwoFragment(), \"ITEM TWO\");adapter.addFragment(new ThreeFragment(), \"ITEM THREE\");viewPager.setAdapter(adapter); TabLayout有提供我們一個基於ViewPager快速創建對應Tabs的方法 java: 123tabLayout = findViewById(R.id.tabLayout_id);tabLayout.setupWithViewPager(viewPager); 運行效果如下： 改變Tab文字顏色，在TabLayout的tag裡，添加屬性 1app:tabTextColor=\"@color/colorWhite\" 運行效果如下： 改變Tab被選中的文字顏色，在TabLayout的tag裡，添加屬性 1app:tabSelectedTextColor=\"@color/colorAccent\" 運行效果如下： 改變TabLayout下方游標顏色，在TabLayout的tag裡，添加屬性 1app:tabIndicatorColor=\"@color/colorLightBlue\" 運行效果如下： 改變TabLayout下方游標高度，在TabLayout的tag裡，添加屬性 1app:tabIndicatorHeight=\"10dp\" 運行效果如下： Create a Tab Layout with Text: Scrollable Mode要創建可滑動的TabLayout，首先把屬性app:tabMode改為scrollable 1app:tabMode=\"scrollable\" 12345678910&lt;android.support.design.widget.TabLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/tabLayout_id\" android:layout_below=\"@+id/toolbar_id\" android:background=\"@color/colorPrimary\" app:tabMode=\"scrollable\" app:tabGravity=\"fill\" app:tabTextColor=\"@android:color/white\" app:tabSelectedTextColor=\"@color/colorAccent\"/&gt; 接著創建十個layout 創建十個Java Class 在Activity裡添加 1234567891011121314ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager());adapter.addFragment(new OneFragment(), \"ITEM ONE\");adapter.addFragment(new TwoFragment(), \"ITEM TWO\");adapter.addFragment(new ThreeFragment(), \"ITEM THREE\");adapter.addFragment(new FourFragment(), \"ITEM FOUR\");adapter.addFragment(new FiveFragment(), \"ITEM FIVE\");adapter.addFragment(new SixFragment(), \"ITEM SIX\");adapter.addFragment(new SevenFragment(), \"ITEM SEVEN\");adapter.addFragment(new EightFragment(), \"ITEM EIGHT\");adapter.addFragment(new NineFragment(), \"ITEM NINE\");adapter.addFragment(new TenFragment(), \"ITEM TEN\");viewPager.setAdapter(adapter);tabLayout.setupWithViewPager(viewPager); 運行效果如下： Create a Tab Layout with Icon接下來我們以Fixed Mode實現，在TabLayout頁籤裡，只顯示icon的效果 首先在XML裡，把app:tabMode設為“fixed” 12345678910&lt;android.support.design.widget.TabLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/tabLayout_id\" android:layout_below=\"@+id/toolbar_id\" android:background=\"@color/colorPrimary\" app:tabMode=\"fixed\" app:tabGravity=\"fill\" app:tabTextColor=\"@android:color/white\" app:tabSelectedTextColor=\"@color/colorAccent\"/&gt; 接著同樣新增3個Layout， 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/recents\" android:layout_centerHorizontal=\"true\" android:layout_centerVertical=\"true\" android:textSize=\"40sp\" android:textStyle=\"bold\"/&gt; &lt;/RelativeLayout&gt; 創建剛剛新增layout的java class(Fragment) 12345678910111213public class RecentsFragment extends Fragment { View view; public RecentsFragment() {} @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { view = inflater.inflate(R.layout.recents_layout,container,false); return view; }} 創建ViewPagerAdapter，這邊我們沒有覆寫getPageTitle()方法 1234567891011121314151617181920212223242526public class ViewPagerAdapter extends FragmentPagerAdapter { private List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;(); private List&lt;String&gt; fragmentTitleList = new ArrayList&lt;&gt;(); public ViewPagerAdapter(FragmentManager fm) { super(fm); } @Override public Fragment getItem(int position) { // Fragment return fragmentList.get(position); } @Override public int getCount() { return fragmentList.size(); } // 添加Fragment 與 Title 方法 public void addFragment(Fragment fragment, String title) { fragmentList.add(fragment); fragmentTitleList.add(title); }} 在Activity裡初始化，在綁定Adapter後，使用getTabAt()取得各項Tab後，設定各個icon 12345678910111213141516171819202122232425262728public class MainActivity extends AppCompatActivity { Toolbar toolbar; TabLayout tabLayout; ViewPager viewPager; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); toolbar = findViewById(R.id.toolbar_id); setSupportActionBar(toolbar); viewPager = findViewById(R.id.viewPager_id); ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager()); adapter.addFragment(new RecentsFragment(),\"RECENTS\"); adapter.addFragment(new FavoritesFragment(),\"FAVORITES\"); adapter.addFragment(new NearbyFragment(),\"NEARBY\"); viewPager.setAdapter(adapter); tabLayout = findViewById(R.id.tabLayout_id); tabLayout.setupWithViewPager(viewPager); // 添加icon tabLayout.getTabAt(0).setIcon(R.drawable.phone); tabLayout.getTabAt(1).setIcon(R.drawable.heart); tabLayout.getTabAt(2).setIcon(R.drawable.account); }} 運行效果如下： Create a Tab Layout with Icon and Text如果想要Tabs同時擁有圖片和文字，只要在ViewPageAdapter裡，覆寫getPageTitle()方法就行了。 123456789101112131415161718192021222324252627282930313233public class ViewPagerAdapter extends FragmentPagerAdapter { private List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;(); private List&lt;String&gt; fragmentTitleList = new ArrayList&lt;&gt;(); public ViewPagerAdapter(FragmentManager fm) { super(fm); } @Override public Fragment getItem(int position) { // Fragment return fragmentList.get(position); } @Override public int getCount() { return fragmentList.size(); } @Nullable @Override public CharSequence getPageTitle(int position) { // 取得當前頁的title return fragmentTitleList.get(position); } // 添加Fragment 與 Title 方法 public void addFragment(Fragment fragment, String title) { fragmentList.add(fragment); fragmentTitleList.add(title); }} 運行效果如下： Create a Tabs item with Java不使用ViewPager，也可以透過代碼創建TabsItem 12345tabLayout = findViewById(R.id.tabLayout_id);tabLayout.addTab(tabLayout.newTab().setText(\"RECENTS\").setIcon(R.drawable.phone));tabLayout.addTab(tabLayout.newTab().setText(\"FAVORITES\").setIcon(R.drawable.heart));tabLayout.addTab(tabLayout.newTab().setText(\"NEARBY\").setIcon(R.drawable.account)); Create a Tabs item in XML不使用ViewPager，在Layout.xml裡，創建TabItem 12345678910111213141516171819202122232425262728&lt;android.support.design.widget.TabLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:id=\"@+id/tabLayout_id\" android:layout_below=\"@+id/toolbar_id\" android:background=\"@color/colorPrimary\" app:tabMode=\"fixed\" app:tabGravity=\"fill\"&gt; &lt;android.support.design.widget.TabItem android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/recents\" android:icon=\"@drawable/phone\"/&gt; &lt;android.support.design.widget.TabItem android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/favorites\" android:icon=\"@drawable/heart\"/&gt; &lt;android.support.design.widget.TabItem android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/nearby\" android:icon=\"@drawable/account\"/&gt;&lt;/android.support.design.widget.TabLayout&gt; 參考資料：Android TabLayoutMaterial Design","link":"/Blog/2018/01/28/MaterialDesign-Android-Tabs/"}],"tags":[{"name":"Android","slug":"Android","link":"/Blog/tags/Android/"},{"name":"Material Design","slug":"Material-Design","link":"/Blog/tags/Material-Design/"}],"categories":[]}